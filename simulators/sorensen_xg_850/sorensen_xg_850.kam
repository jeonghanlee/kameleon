# author: Martin Angelsmark
# email: martin.angelsmark@esss.se
# copyright: (C) 2017 European Spallation Source (ESS)
# version: 1.0.2
# date: 2017/AUG/18
# description: Kameleon simulator file for the Sorensen XG 850W (power supply)

from __future__ import print_function
import copy



# The terminator (EOL) of commands/statuses is described in the "TERMINATOR" variable. By default, the terminator is not defined (i.e. is empty). If defined, the terminator is inserted at the end of both the commands and statuses received/sent from/to clients before Kameleon starts to process these. The generic form of this variable is:
#
#    TERMINATOR = value
#
# Where value can either be an arbitrary string (e.g. "END") or one of the following pre-defined terminators:
#
#    LF     : the terminator is a line feed (0xA).
#    CR     : the terminator is a carriage return (0xD).
#    LF + CR: the terminator is a line feed (0xA) followed by a carriage return (0xD).
#    CR + LF: the terminator is a carriage return (0xD) followed by a line feed (0xA).
#
# In case of need to setup different terminators for commands and statuses, the "TERMINATOR" and "TERMINATOR_STS" variables can be used respectively (e.g. TERMINATOR = LF).

TERMINATOR = CR+LF



# Data (i.e. commands) received from the client are described in the "COMMANDS" list. The generic form of this list is:
#
#    COMMANDS = [[description_1, command_1, status_1, wait_1], [description_2, command_2, status_2, wait_2], ..., [description_X, command_X, status_X, wait_X]]
#
# Where:
#
#    description: (mandatory) string that describes the command (e.g. "Set power on").
#    command    : (mandatory) string that represents the command (e.g. "AC1"). Only data (received from the client) that matches exactly the command is selected. Additional matching policies are available:
#                    - if command starts with "***", any data (received from the client) that ends with command is selected.
#                    - if command ends with "***", any data (received from the client) that starts with command is selected.
#                    - if command starts and ends with "***", any data (received from the client) that contains the command is selected.
#    status     : (optional) integer, list or string that specifies the index(es) of the status(es) (stored in the "STATUSES" list) to send to the client or a user-defined function (to be called by Kameleon) after the command is selected. The first status (stored in "STATUSES" list) is at index 1. If 0 or not specified, no status is sent.
#    wait       : (optional) integer that specifies the time to wait (in milliseconds) before sending the status to the client. If 0 or not specified, the status is immediately sent (i.e. right after the command is received).


# NOTE: The way this file reads the commands is a bit excessive. I recomend that if another kam 
#		file will be developed for a machine with similar syntax, either a smarter way of reading 
#		the chain of commands needs to be created or the commands should instead be implemented 
#		directly in the COMMANDS list, e.g. ["SOURALL:CURR ***", "SOURceALL:CURRent ***", 
#		"SOUR0:CURR ***", "SOURce0:CURRent ***", "SOUR1:CURR ***", "SOURce1:CURRent ***",
#		..., "SOUR30:CURR ***", "SOURce30:CURRent ***"], in order to simplify things. There is not 
#		enough time to improve this file at the moment (and it does work), but it will probably be 
#		good if new files avoid this method of reading commands.

COMMANDS = [["SOURCE command subsystem", ["SOUR***", "sour***", ":SOUR***", ":sour***"], 1],
			["MEASURE command subsystem", ["MEAS***", "meas***", ":MEAS***", ":meas***"], 2],
			["OUTPUT command subsystem", ["OUTP***", "outp***", ":OUTP***", ":outp***"], 3],
			["STATUS command subsystem", ["STAT***", "stat***", ":STAT***", ":stat***"], 4],	#NOTE! The status subcommands are not yet implemented
			["SYSTEM command subsystem", ["SYST***", "syst***", ":SYST***", ":syst***"], 5],	#NOTE! The system subcommands are not yet implemented
			["CALIBRATION command subsystem", ["CAL***", "cal***", ":CAL***", ":cal***"], 6],
			["INITIATE command subsystem", ["INIT***", "init***", ":INIT***", ":init***"], 7],
			["PROGRAM command subsystem", ["PROG***", "prog***", ":PROG***", ":prog***"], 8],
			["SENSE command subsystem", ["SENS***", "sens***", ":SENS***", ":sens***"], 9],
			["COMMON command ADR?", "*ADR?", 10],
			["COMMON command ADR", "*ADR***", "cmd_ADR()"],
			["COMMON command CLS", "*CLS", "cmd_CLS()"],
			["COMMON command ERR", "*ERR", "read_system_error()"],
			["COMMON command ESE?", "*ESE?", 11],
			["COMMON command ESE", "*ESE***", "cmd_ESE()"],
			["COMMON command ESR?", "*ESR?", 12],
			["COMMON command HELP?", "*HELP?", 13],
			["COMMON command IDN?", "*IDN?", 14],
			["COMMON command OPC", "*OPC", "cmd_OPC()"],
			["COMMON command *OPC?", "*OPC?", 15],
			["COMMON command *RCL", "*RCL", "cmd_RCL()"],
			["COMMON command RST", "*RST", "cmd_RST()"],
			["COMMON command SAV", "*SAV", "cmd_SAV()"],
			["COMMON command SRE?", "*SRE?", 16],
			["COMMON command SRE", "*SRE***", "cmd_SRE()"],
			["COMMON command STB?", "*STB?", 17],
			["COMMON command TRG", "*TRG", "cmd_TRG()"],
			["COMMON command TST?", "*TST?", 18],
			["COMMON command WAI", "*WAI", "cmd_WAI()"],
			["Syntax error", "***", 19]]



# Data (i.e. statuses) sent to the client are described in the "STATUSES" list. The generic form of this list is:
#
#    STATUSES = [[description_1, behavior_1, value_1, prefix_1, suffix_1, timeout_1], [description_2, behavior_2, value_2, prefix_2, suffix_2, timeout_2]], ..., [description_X, behavior_X, value_X, prefix_X, suffix_X, timeout_X]]
#
# Where:
#
#    description: (mandatory) string that describes the status (e.g. "Get temperature value").
#    behavior   : (mandatory) integer that specifies the behavior for generating the status. It can either be:
#                    - FIXED (sends a fixed value to the client)
#                    - ENUM (sends a value - belonging to an enumeration - to the client)
#                    - INCR (sends an incremented value to the client)
#                    - RANDOM (sends a random value to the client)
#                    - CUSTOM (sends a value from a user-defined function to the client)
#    value      : (mandatory) value to send to the client. Depending on the behavior, it can either be an integer, float, string or list:
#                    - when FIXED, the value is expected to be an integer, float or string. Independently of how many times it is sent to the client, the value remains the same (i.e. does not change).
#                    - when ENUM, the value is expected to be a list. It represents a set of elements (enumeration). After sending an element of the list to the client, the next value to be sent is the next element in the list. When the last element is sent, the next to be sent is the the first element of the list.
#                    - when INCR, the value is expected to be an integer, float or list. If an integer or float, the first value to be sent is a 0 and subsequent values to be sent are incremented by value. If a list, the lower bound, upper bound and increment values are defined by the first, second and third elements of the list, respectively.
#                    - when RANDOM, the value is expected to be an integer or a list. If an integer, a random number between 0 and value is generated. If a list, the lower and upper bounds of the random number to generate are defined by the first and second elements of the list, respectively. The generated random number is sent to the client.
#                    - when CUSTOM, the value is expected to be a string. It contains the name of a user-defined Python function to be called by Kameleon. The value returned by this function is sent to the client (if the function does not return a value or it returns None, nothing is sent).
#    prefix     : (optional) string that contains the prefix to insert at the beginning of the value to send to the client. If not specified, nothing is inserted.
#    suffix     : (optional) string that contains the suffix to insert at the end of the value to send to the client. If not specified, nothing is inserted.
#    timeout    : (optional) integer that specifies the time-out (in milliseconds) after which the status is sent to the client (i.e. time-based). If 0 or not specified, the status is only sent after receiving a command from the client (i.e. event-based).

STATUSES = [["SOURCE command subsystem", CUSTOM, "cmd_Source()"],
			["MEASURE command subsystem", CUSTOM, "cmd_Measure()"],
			["OUTPUT command subsystem", CUSTOM, "cmd_Output()"],
			["STATUS command subsystem", CUSTOM, "cmd_Status()"],
			["SYSTEM command subsystem", CUSTOM, "cmd_System()"],
			["CALIBRATION command subsystem", CUSTOM, "cmd_Calibration()"],
			["INITIATE command subsystem", CUSTOM, "cmd_Initiate()"],
			["PROGRAM command subsystem", CUSTOM, "cmd_Program()"],
			["SENSE command subsystem", CUSTOM, "cmd_Sense()"],
			["COMMON command ADR?", CUSTOM, "cmd_read_ADR()"],
			["COMMON command ESE?", CUSTOM, "cmd_read_ESE()"],
			["COMMON command ESR?", CUSTOM, "cmd_read_ESR()"],
			["COMMON command HELP?", CUSTOM, "cmd_read_HELP()"],
			["COMMON command IDN?", CUSTOM, "cmd_read_IDN()"],
			["COMMON command OPC?", CUSTOM, "cmd_read_OPC()"],
			["COMMON command SRE?", CUSTOM, "cmd_read_SRE()"],
			["COMMON command STB?", CUSTOM, "cmd_read_STB()"],
			["COMMON command TST?", CUSTOM, "cmd_read_TST()"],
			["Syntax error", CUSTOM, "err_syntax_error([address])"]]




####################################################################################################
# User-custom Python code
####################################################################################################
#
# Variables
####################################################################################################

#Source_subcommand__________________________________________________________________________________
	#Voltage and current does not affect each other in this simulation.
	#Constant current/voltage/power is not implemented

#Current share controller
current_share = ["CONT"] * 30	#No idea what this represent

#Constant power
constant_power_set_point = 0
constant_power_mode = 0

#Current
output_current = [0] * 30
maximum_current = [42] * 30	#ASSUMPTION it is the 20-42 model
minimum_current = [0] * 30

#Voltage
output_voltage = [0] * 30
maximum_voltage = [20] * 30
minimum_voltage = [0] * 30
overvoltage = [1.1 * value for value in maximum_voltage] 	#Overvoltage protection, kills voltage if exceeded. Considered off if over max. value
undervoltage = [0] * 30	#Undervoltage protection, kills voltage if it exceeds outgoing voltage. Considered off if 0
tripped_over_flag = [0] * 30  #Flag in case the overvoltage is tripped
tripped_under_flag = [0] * 30  #Flag in case the undervoltage is tripped


#Measure_subcommand_________________________________________________________________________________
	#I just return the output. This obviously does not represent how the machine works

#Current
meas_current = [0] * 30 	#an average of measured current

#Voltage
meas_voltage = [0] * 30 	#an average of measured voltage


#Output_subcommand__________________________________________________________________________________
	#I believe communication is correct but the commands have no effect on the machine.

output_polarity = ["HIGH"] * 30	#TTL level that will trigger external shutdown (No idea, feel like it should be a number)
foldback_delay = [0.5] * 30	#Delay time before foldback protection is triggered (not implemented)
foldback_mode = ["NONE"] * 30	#Condition for foldback
output_power_state = [0] * 30	#Main output state (Does not actually turn on/off output)
output_autostart = [0] * 30	#No idea when autostart is triggered
output_auxilliary_state = [0] * 30	#Don't know what Aux Output is
output_auxilliary_autostart = [0] * 30

#System_subcommand__________________________________________________________________________________
	#There are a number of variables that I do not know the purpose of in the system subcommands.
	#Commands should have correct communication but does not affect the machine.
	#Resetting to default is not implemented
	#Saving and loading values is not implemented.

fpanel_timeout = [1] * 30	#Menu system timeout (Don't know what it is)
apg_voltage = [2] * 30	#Level for Voltage APG (Don't know what it is)
apg_current = [2] * 30 	#Level for Current APG (Don't know what it is)
system_address = ["APG1059-37"] * 30	#Address set on the front panel under the remote (Don't know syntax)
apg_voltage_state = ["LOC"] * 30	#State of the remote programming voltage APG source (Don't know what it is)
apg_current_state = ["LOC"] * 30	#State of the remote programming current APG source (Don't know what it is)
remote_state = ["REM"] * 30	#Front panel control mode (local or remote)
pon_voltage = [0] * 30	#I think if it is on the voltage set point (Don't know what it is) 
						#is set to zero when power is turned on
pon_current = [0] * 30	#I think if it is on the current set point (Don't know what it is) 
						#is set to zero when power is turned on
pon_enable_voltage = [0] * 30	#I think if it is on the voltage set point (Don't know what it is) 
								#is set to zero when output enable button is pressed
pon_enable_current = [0] * 30	#I think if it is on the current set point (Don't know what it is) 
								#is set to zero when output enable button is pressed
protection_enable_mask = [0b00000000] * 30
system_protection_latch = [0b000000000] * 30	#Alarm Output Latches, see Table 3-6 on page 3-24 (Don't know what it is)

#Status_subcommand__________________________________________________________________________________
	#Most event commands and enable commadns work as I believe they should.
	#However, I do not know what the condition and ntrans and ptrans registers are supposed to do.

operation_condition_register = [0b0000000000000000] * 30
operation_enable_register = [0b1111111111111111] * 30	#I believe enable register chooses which bits activate summary
												#bits in other registers
operation_event_register = [0b0001000000000000] * 30	#Supply in calibration mode, bit 1 to 8 not used,
							#summary shutdown, front panel lockout, summary cshare, constant voltage mode,
							#constant current mode, Autosequence program running
operation_ntrans_register = [0b0000000000000000] * 30
operation_ptrans_register = [0b0000000000000000] * 30
operation_shutdown_condition_register = [0b0000] * 30
operation_shutdown_enable_register = [0b1111] * 30
operation_shutdown_event_register = [0b0000] * 30	#Summary protection, shut down by interlock signal,
							#not used, shut down by external shutdown signal
operation_shutdown_ntrans_register = [0b0000] * 30
operation_shutdown_ptrans_register = [0b0000] * 30
operation_shutdown_protection_condition_register = [0b000000000] * 30
operation_shutdown_protection_enable_register = [0b111111111] * 30
operation_shutdown_protection_event_register = [0b000000000] * 30	#Over voltage protection tripped,
							#under voltage protection tripped, over current protection tripped,
							#not used, AC off (protection tripped), over temperature protection tripped,
							#not used, foldback protection tripped, fan failure
operation_shutdown_protection_ntrans_register = [0b000000000] * 30
operation_shutdown_protection_ptrans_register = [0b000000000] * 30
operation_cshare_event_register = [0b01] * 30	#Configured to current share controller,
							#configured to current share slave
operation_cshare_enable_register = [0b11] * 30
operation_cshare_condition_register = [0b00] * 30
operation_cshare_ptrans_register = [0b00] * 30
operation_cshare_ntrans_register = [0b00] * 30
questionable_event_register = [0b000000000] * 30	#Summary voltage register, 1 to 3 not used,
							#summary temperature register, 5 to 8 not used
questionable_enable_register = [0b111111111] * 30
questionable_condition_register = [0b000000000] * 30
questionable_ntrans_register = [0b000000000] * 30
questionable_ptrans_register = [0b000000000] * 30
questionable_temperature_event_register = [0b0] * 30	#Over temperature protection
questionable_temperature_enable_register = [0b1] * 30
questionable_temperature_condition_register = [0b0] * 30
questionable_temperature_ntrans_register = [0b0] * 30
questionable_temperature_ptrans_register = [0b0] * 30
questionable_voltage_event_register = [0b00] * 30	#Over voltage protection, under voltage protection
questionable_voltage_enable_register = [0b11] * 30
questionable_voltage_condition_register = [0b00] * 30
questionable_voltage_ntrans_register = [0b00] * 30
questionable_voltage_ptrans_register = [0b00] * 30
status_byte_register = [0b00000000] * 30 	#not used, not used, error message available, 
							#summary questionable event register,
							#output queue empty, summary standard event status register, 
							#RQS (not used) / Master Status summary (used),
							#summary operation status register
standard_event_register = [0b00000000] * 30 	#operation complete, request control (not used),
							#query error (not used), device dependent error, execution error, 
							#command error, user request (not used), power on (not used)
standard_enable_register = [0b11111111] * 30	#Chooses which bits actiate bit 6 in byte register
srequest_enable_register = [0b11111111] * 30	#Selects which bit in standard event register
							#causes service requests

#Calibration_subcommand_____________________________________________________________________________
	#The automatic or interactive mode are not implemented. They just return nothing.
	#The others you can set and read values but does not affect the machine.

calibrate_input_voltage = [0] * 30
calibrate_output_voltage = [0] * 30
calibrate_voltage_analog = [0] * 30
calibrate_voltage_isolated = [0] * 30
calibrate_voltage_resistive = [0] * 30
calibrate_voltage_resistive_isolated = [0] * 30
calibrate_monitor_voltage = [0] * 30
calibrate_monitor_voltage_isolated = [0] * 30
calibrate_input_current = [0] * 30
calibrate_output_current = [0] * 30
calibrate_current_analog = [0] * 30
calibrate_current_isolated = [0] * 30
calibrate_current_resistive = [0] * 30
calibrate_current_resistive_isolated = [0] * 30
calibrate_monitor_current = [0] * 30
calibrate_monitor_current_isolated = [0] * 30

factory_calibration = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] for x in xrange(0, 30)]
stored_calibration = copy.deepcopy(factory_calibration)

#Sense______________________________________________________________________________________________
interlock_system_state = [0] * 30	#Don't know what it does

#Program____________________________________________________________________________________________
	#Sequences are not implemented so the commands do not do anything. Readback subcommand does
	#not return correct status.
sequence_state = ["STOP"] * 30
sequence_repeat = [1] * 30
sequence_dwel = [0] * 30

#Error______________________________________________________________________________________________
ERR = [[0,0,0,0,0,0,0,0,0,0] for x in xrange(0, 30)] 	#Can hold 10 error message (0 = no error)

#Common_commands____________________________________________________________________________________
address = 0	#The default channel you access if no channel is specified.
OPC_flag = [0] * 30	#Believe it enables the first bit in standard_event_register to be set



####################################################################################################
# Common command subsystem
####################################################################################################

#Chooses which channel is default
def cmd_ADR():
	global address

	data = COMMAND_RECEIVED.split(" ")
	print("data:", data)

	count = 0	#check the number of elements in data
	for elements in data:
		count += 1

	if count == 2:
		if data[0] == "*ADR":
			if is_number(data[1]):
				if float(data[1]).is_integer():
					if 0 < int(data[1]) <= 30:
						address = int(data[1]) - 1
						return None
					else:
						err_data_out_of_range([address])
						return None
	else:
		err_wrong_number_of_parameters(count, 2, [address])	#If count is not 2
		return None

	err_syntax_error([address])	#If something else is wrong
	return None

def cmd_read_ADR():
	return address

#Clears all status reporting data structures
def cmd_CLS():
	return status_clear()

#Sets value of standard event status enable register
def cmd_ESE():
	data = COMMAND_RECEIVED.split(" ")
	print("data:", data)

	count = 0	#check the number of elements in data
	for elements in data:
		count += 1

	if count == 2:
		if data[0] == "*ESE":
			return write_status_standard_enable(data[1], [address])
	else:
		err_wrong_number_of_parameters(count, 2, [address])	#If count is not 2
		return None

	err_syntax_error([address])	#If something else is wrong
	return None

#Return standard event status enable register
def cmd_read_ESE():
	return read_status_standard_enable([address], 1)

#Return standard event status register
def cmd_read_ESR():
	return read_status_standard_event([address], 1)

#Return all headers available
def cmd_read_HELP():
	return read_system_help_header([address], 1)

#Returns device identification
def cmd_read_IDN():
	return read_system_id([address], 1)

#Enable Operation Complete bit of the Standard Event Status
def cmd_OPC():
	global OPC_flag

	OPC_flag[address] = 1
	set_standard_event_register(address)

#Assumption: Returns 1 when all pending operations are complete
def cmd_read_OPC():
	#ASSUMPTION: Pending operations are operations waiting for *WAI to clear
	return 1

#Read saved values at a certain setting index (1-5)	But other command description says 0-3, I will use that
def cmd_RCL():
	data = COMMAND_RECEIVED.split(" ")
	print("data:", data)

	count = 0	#check the number of elements in data
	for elements in data:
		count += 1

	if count == 2:
		if data[0] == "*RCL":
			return system_recall(data[1], [address])
	else:
		err_wrong_number_of_parameters(count, 2, [address])
		return None

	err_syntax_error([address])
	return None

#Reset to power on state
def cmd_RST():	#Should reset all values except calibration data
	system_reset([address])

#Saves values
def cmd_SAV():
	data = COMMAND_RECEIVED.split(" ")
	print("data:", data)

	count = 0	#check the number of elements in data
	for elements in data:
		count += 1

	if count == 2:
		if data[0] == "*SAV":
			return system_save(data[1], [address])
	else:
		err_wrong_number_of_parameters(count, 2, [address])
		return None

	err_syntax_error([address])
	return None

#Sets the value of the service request enable register
def cmd_SRE():
	#Don't know what this does
	global srequest_enable_register

	data = COMMAND_RECEIVED.split(" ")
	print("data:", data)

	count = 0	#check the number of elements in datas
	for elements in data:
		count += 1

	if count == 2:
		if data[0] == "*SRE":
			return write_status_srequest_enable(data[1], [address])
	else:
		err_wrong_number_of_parameters(count, 2, [address])
		return None

	err_syntax_error([address])
	return None

#Returns value of the service request enable register
def cmd_read_SRE():
	return read_status_srequest_enable([address], 1)

#Returns status byte with MSS at bit 6
def cmd_read_STB():
	return read_status_sbyte_event([address], 1)

#Trigger system (Don't know yet what it triggers)
def cmd_TRG():
	return None

#Internal self-test and return integer value
def cmd_read_TST():
	return read_system_test([address], 1)

#Sets the device to wait until all previous commands and queries are completed before executing commands following *WAI command
def cmd_WAI():
	return system_wait([address])



####################################################################################################
# SOURCE subsystem fcns
####################################################################################################

#fcn for the source command subsystem
def cmd_Source():
	print("Entered source subsystem")

	data1 = COMMAND_RECEIVED.upper().split(":")
	print("data1:", data1)

	if data1[0] == "":
		data1 = data1[1:]

	command_count = 0	#check the number of elements in data (number of "commands")
	for elements in data1:
		command_count += 1

	data2 = data1[command_count-1].split(" ")	#Split last element in data in case a parameter was given
	print("data2:", data2)
	data1 = data1[:(command_count-1)]	#Erase last element from data1
	print("new data1:", data1)
	commands = data1 + data2[:1]	#... and replace it with the first element of data 2. This way we omitt all parameters.
	parameters = data2[1:]	#Save the parameters in another variable
	print("commands:", commands)

	parameter_count = 0	#Count number of given parameters
	for elements in parameters:
		parameter_count += 1
		
	if parameter_count == 1:
		parameters = parameters[0].split(",")	#Parameters can also be separated by commas
		
		parameter_count = 0	#Count number of given parameters again
		for elements in parameters:
			parameter_count += 1
	
	print("parameters:", parameters)

	#Read which channel we look at:
	data3 = [commands[0].split("E"), commands[0].split("R")]
	print("data3:", data3)
	command = [data3[0][0] + "E", data3[1][0] + "R"]
	print("first command list:", command)


	for i in xrange(0, 2):
		if source_bool(command[i], 001):
			channel = data3[i][1].split(",")
			print("channel:", channel)

			channel_count = 0	#check the number of elements in channel
			for elements in channel:
				channel_count += 1

			counter = 0
			ch = [0] * channel_count
			for elements in channel:
				if is_number(elements):
					if float(elements).is_integer():
						if 1 <= int(elements) <= 30:
							ch[counter] = int(elements) - 1	#Index of the parameters
							commands[0] = command[i]
						elif int(elements) == 0 and channel_count == 1:
							ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
							commands[0] = command[i]
						else:
							err_syntax_error("ALL")
							return None
					else:
						err_syntax_error("ALL")
						return None
				elif elements == "" and channel_count == 1:
					ch[counter] = address	#Set index to default channel
					commands[0] = command[i]
				elif elements == "ALL" and channel_count == 1:
					ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
					commands[0] = command[i]
				else:
					err_syntax_error("ALL")
					return None

				counter += 1
			break

	print("The channel index is:", ch)
	print("commands:", commands)


	if source_bool(commands[0], 001) and command_count > 1:	#Check if correct command. OBS! Only giving command source doesn't do anything.
		if combine_bool(commands[1], 001):	#SOUR:COMB
			return fcn_source_combine_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)	#Enter function for combine subsystem
		elif current_bool(commands[1], 001):	#SOUR:CURR
			return fcn_source_current_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)	#Enter function for current subsystem
		elif current_bool(commands[1], 010):	#SOUR:CURR?
			if command_count == 2:	#Check that no other sub commands are given
				return read_output_current(parameters, parameter_count, ch, channel_count)	#return the value of the output current
		elif power_bool(commands[1], 001):
			if source_optional_commands(commands[2], 0000001):	#SOUR:POW:LEV
				if parameter_count == 1:
					if channel == [""]:
						return write_power_set_point(parameters[0])
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)	#Error if parameters where given
					return None
			elif source_optional_commands(commands[2], 0001000):	#SOUR:POW:LEV?
				if parameter_count == 0:
					if channel == [""]:
						return read_power_set_point()
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)	#Error if parameters where given
					return None
			elif mode_bool(commands[2], 001):	#SOUR:POW:MOD
				if parameter_count == 1:
					if channel == [""]:
						return write_constant_power_mode(parameters[0])
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)	#Error if parameters where given
					return None
			elif mode_bool(commands[2], 010):	#SOUR:POW:MOD?
				if parameter_count == 0:
					if channel == [""]:
						return read_constant_power_mode()
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)	#Error if parameters where given
					return None
		elif voltage_bool(commands[1], 001):	#SOUR:VOLT
			return fcn_source_voltage_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif voltage_bool(commands[1], 010):	#SOUR:VOLT?
			if command_count == 2:	#Check that no other sub commands are given
				return read_output_voltage(parameters, parameter_count, ch, channel_count)	#return the value of the output voltage

	err_syntax_error(ch)	#If some command was wrong enter syntax error
	return None


#Fcn for source:combine subsystem
def fcn_source_combine_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("I entered fcn source combine")

	if cshare_bool(commands[2], 001):	#SOUR:COM:CSH
		if command_count == 3:
			if parameter_count == 1:
				return write_current_share(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif command_count == 4:
			if mode_bool(commands[3], 001):	#SOUR:COM:CSH:MOD
				if parameter_count == 1:
					return write_current_share(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif mode_bool(commands[3], 010):	#SOUR:COM:CSH:MOD?
				if parameter_count == 0:
					return read_current_share(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif cshare_bool(commands[2], 010):	#SOUR:COM:CSH?
		if parameter_count == 0:
			return read_current_share(ch, channel_count)
		else:
			err_wrong_number_of_parameters(parameter_count, 0, ch)
			return None


#Fcn for source:current subsystem
def fcn_source_current_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("I entered fcn source current")
	print(commands, parameters, command_count, parameter_count)

	command_flag = 0	#Flag that checks if all commands given are correct
	for index in xrange(2, command_count):
		if not source_optional_commands(commands[index], 0111111):	#Only enter if incorrect commands.
			command_flag = 1
			break

	if command_flag == 0:	#Enter if command_flag was not activated
		if current_bool(commands[command_count-1], 001) or source_optional_commands(commands[command_count-1], 0000111):	#Enter if no "?"
			if parameter_count == 1:	#Check if only value was given
				return write_output_current(parameters[0], ch)	#Call function to write output current
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif current_bool(commands[command_count-1], 010) or source_optional_commands(commands[command_count-1], 0111000):
			return read_output_current(parameters, parameter_count, ch, channel_count)	#Read output current

	err_syntax_error(ch)
	return None


#Fcn for source:voltage subsystem
def fcn_source_voltage_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("I entered fcn source voltage")

	command_flag = 0	#Flag that checks if all commands given are correct
	for index in xrange(2, command_count):
		if protection_bool(commands[index], 011):
			return fcn_voltage_protection_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif not source_optional_commands(commands[index], 0111111):	#Only enter if incorrect commands.
			command_flag = 1
			break

	if command_flag == 0:	#Enter if command_flag was not activated
		if voltage_bool(commands[command_count-1], 001) or source_optional_commands(commands[command_count-1], 0000111):	#Enter if no "?"
			if parameter_count == 1:	#Check if only value was given
				return write_output_voltage(parameters[0], ch)	#Call function to write output voltage
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif voltage_bool(commands[command_count-1], 010) or source_optional_commands(commands[command_count-1], 0111000):	#Enter if "?"
			return read_output_voltage(parameters, parameter_count, ch, channel_count)	#Read output voltage if command flag was not activated

	err_syntax_error(ch)
	return None


#Dcn for source:voltage:protection subsystem
def fcn_voltage_protection_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered protection subsystem")

	if not protection_bool(commands[command_count-1], 011):	#Check if last command was not "protection" or "protection?"
		if protection_bool(commands[command_count-3], 001):	#Check if third to last command was "protection"
			if overvoltage_bool(commands[command_count -2], 001):	#Check if optional commands are correct
				if source_optional_commands(commands[command_count-1], 0000001):	#SOUR:VOLT:PROT:OVER:LEV
					if parameter_count == 1:
						return write_overvoltage(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
				elif source_optional_commands(commands[command_count-1], 0001000):	#SOUR:VOLT:PROT:OVER:LEV?
					if parameter_count == 0:
						return read_overvoltage(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
			elif under_bool(commands[command_count -2], 001):
				if source_optional_commands(commands[command_count-1], 0000001):	#SOUR:VOLT:PROT:UND:LEV
					if parameter_count == 1:
						return write_undervoltage(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
				elif source_optional_commands(commands[command_count-1], 0001000):	#SOUR:VOLT:PROT:UND:LEV?
					if parameter_count == 0:
						return read_undervoltage(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif protection_bool(commands[command_count-2], 001): #Check if second to last command was "protection"
			if overvoltage_bool(commands[command_count -1], 001):	#SOUR:VOLT:PROT:OVER
				if parameter_count == 1:
					return write_overvoltage(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif overvoltage_bool(commands[command_count -1], 010):	#SOUR:VOLT:PROT:OVER?
				if parameter_count == 0:
					return read_overvoltage(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
			elif source_optional_commands(commands[command_count-1], 0000001):	#SOUR:VOLT:PROT:LEV
				if parameter_count == 1:
					return write_overvoltage(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif source_optional_commands(commands[command_count-1], 0001000):	#SOUR:VOLT:PROT:LEV?
				if parameter_count == 0:
					return read_overvoltage(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
			elif under_bool(commands[command_count -1], 001):	#SOUR:VOLT:PROT:UND
				print("entered wrong and parameter count is:", parameter_count)
				if parameter_count == 1:
					return write_undervoltage(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif under_bool(commands[command_count -1], 010):	#SOUR:VOLT:PROT:UND?
				print("entered here and parameter count is:", parameter_count)
				if parameter_count == 0:
					return read_undervoltage(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif protection_bool(commands[command_count-1], 001):	#SOUR:VOLT:PROT
		if parameter_count == 1:	#Check if only value was given
			return write_overvoltage(parameters[0], ch)	#Call function to write overvoltage (voltage protection trip point)
		else:
			err_wrong_number_of_parameters(parameter_count, 1, ch)
			return None
	elif protection_bool(commands[command_count-1], 010):	#SOUR:VOLT:PROT?
		if parameter_count == 0:
			return read_overvoltage(ch, channel_count)	#Read overvoltage
		else:
			err_wrong_number_of_parameters(parameter_count, 0, ch)
			return None

	err_syntax_error(ch)
	return None	#Add some error here?



####################################################################################################
# Measure subsystem fcns
####################################################################################################

#Fcn for measure subsystem
def cmd_Measure():
	print("Entered measure subsystem")

	data1 = COMMAND_RECEIVED.upper().split(":")
	print("data1:", data1)

	if data1[0] == "":
		data1 = data1[1:]

	command_count = 0	#check the number of elements in data (number of "commands")
	for elements in data1:
		command_count += 1

	data2 = data1[command_count-1].split(" ")	#Split last element in data in case a parameter was given
	print("data2:", data2)
	data1 = data1[:(command_count-1)]	#Erase last element from data1
	print("new data1:", data1)
	commands = data1 + data2[:1]	#... and replace it with the first element of data 2. This way we omitt all parameters.
	parameters = data2[1:]	#Save the parameters in another variable
	print("commands:", commands)
	
	parameter_count = 0	#Count number of given parameters
	for elements in parameters:
		parameter_count += 1
		
	if parameter_count == 1:
		parameters = parameters[0].split(",")	#Parameters can also be separated by commas
		
		parameter_count = 0	#Count number of given parameters again
		for elements in parameters:
			parameter_count += 1
	
	print("parameters:", parameters)

	#Read which channel we look at:
	data3 = [commands[0].split("S"), commands[0].split("E")]
	print("data3:", data3)
	command = [data3[0][0] + "S", data3[1][0] + "E"+ data3[1][1] + "E"]
	print("first command list:", command)


	for i in xrange(0, 2):
		if measure_bool(command[i], 011):
			channel = data3[i][-1].split(",")
			print("channel:", channel)

			channel_count = 0	#check the number of elements in channel
			for elements in channel:
				channel_count += 1

			counter = 0
			ch = [0] * channel_count
			for elements in channel:
				if is_number(elements):
					if float(elements).is_integer():
						if 1 <= int(elements) <= 30:
							ch[counter] = int(elements) - 1	#Index of the parameters
							commands[0] = command[i]
						elif int(elements) == 0 and channel_count == 1:
							ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
							commands[0] = command[i]
						else:
							err_syntax_error("ALL")
							return None
					else:
						err_syntax_error("ALL")
						return None
				elif elements == "" and channel_count == 1:
					ch[counter] = address	#Set index to default channel
					commands[0] = command[i]
				elif elements == "ALL" and channel_count == 1:
					ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
					commands[0] = command[i]
				elif elements == "?" + TERMINATOR and channel_count == 1:
					ch[counter] = address	#Set index to default channel
					commands[0] = command[i] + "?"
				else:
					err_syntax_error("ALL")
					return None

				counter += 1
			break

	print("The channel index is:", ch)
	print("commands:", commands)


	if measure_bool(commands[0], 010):	#MEAS?
		if command_count == 1:
			if parameter_count == 0:
				return measure_voltage(ch, channel_count)
	elif measure_bool(commands[0], 001):	#MEAS
		if aprogram_bool(commands[1], 011):
			if channel == [""]:
				return fcn_measure_aprogram_subsystem(commands, parameters, command_count, parameter_count)
		elif current_bool(commands[1], 011):	#MEAS:CURR
			return fcn_measure_current_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif voltage_bool(commands[1], 011):	#MEAS:VOLT
			return fcn_measure_voltage_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif scalar_bool(commands[1], 001):	#MEAS:SCAL
			if aprogram_bool(commands[2], 011):	#MEAS:SCAL:APR
				if channel == [""]:
					return fcn_measure_aprogram_subsystem(commands, parameters, command_count, parameter_count)
			elif current_bool(commands[2], 011):	#MEAS:SCAL:CURR
				return fcn_measure_current_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
			else:
				return fcn_measure_voltage_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif dc_bool(commands[1], 010):	#MEAS:DC?
			return fcn_measure_voltage_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)

	err_syntax_error(ch)
	return None


#Fcn for measure:aprogram subsystem
def fcn_measure_aprogram_subsystem(commands, parameters, command_count, parameter_count):
	print("Entered measure:aprogram subsystem")

	command_flag = 0	#Flag that checks if all commands given are correct
	for index in xrange(2, command_count):
		if current_bool(commands[index], 011):
			return fcn_aprogram_current_subsystem(commands, parameters, command_count, parameter_count)
		elif not (voltage_bool(commands[index], 011) or isolated_bool(commands[index], 011) or dc_bool(commands[index], 011) or aprogram_bool(commands[index], 011)):	#Only enter if incorrect commands.
			err_syntax_error(ch)
			return None

	if isolated_bool(commands[command_count-1], 010):	#MEAS:APR:[VOLT]:ISOL?
		if parameter_count == 0:
			return measure_aprogram_voltage_isolated()
		else:
			err_wrong_number_of_parameters(parameter_count, 0, ch)
			return None
	elif isolated_bool(commands[command_count-2], 001):
		if dc_bool(commands[command_count-1], 010):	#MEAS:APR:[VOLT]:ISOL:DC?
			if parameter_count == 0:
				return measure_aprogram_voltage_isolated()
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	else:	#MEAS:APR:[VOLT]:[DC]?
		if parameter_count == 0:
			return measure_aprogram_voltage()
		else:
			err_wrong_number_of_parameters(parameter_count, 0, ch)
			return None

#Fcn for measure:aprogram:current subsystem
def fcn_aprogram_current_subsystem(commands, parameters, command_count, parameter_count):
	print("Entered measure:aprogram:current subsystem")

	if dc_bool(commands[command_count-1], 010):
		if current_bool(commands[command_count-2], 001):	#MEAS:APR:CURR:DC?
			if parameter_count == 0:
				return measure_aprogram_current()
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
		elif isolated_bool(commands[command_count-2], 001):
			if current_bool(commands[command_count-3], 001):	#MEAS:APR:CURR:ISOL:DC?
				if parameter_count == 0:
					return measure_aprogram_current_isolated()
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif isolated_bool(commands[command_count-1], 010):
		if current_bool(commands[command_count-2], 001):	#MEAS:APR:CURR:ISOL?
			if parameter_count == 0:
				return measure_aprogram_current_isolated()
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif current_bool(commands[command_count-1], 010):	#MEAS:APR:CURR:?
		if parameter_count == 0:
			return measure_aprogram_current()
		else:
			err_wrong_number_of_parameters(parameter_count, 0, ch)
			return None

	err_syntax_error(ch)
	return None

#Fcn for measure:current subsystem
def fcn_measure_current_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered measure:current subsystem")

	if current_bool(commands[command_count-2], 001):
		if dc_bool(commands[command_count-1], 010):	#MEAS:CURR:DC?
			if parameter_count == 0:
				return measure_current(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif current_bool(commands[command_count-1], 010):	#MEAS:CURR?
		if parameter_count == 0:
			return measure_current(ch, channel_count)
		else:
			err_wrong_number_of_parameters(parameter_count, 0, ch)
			return None

	err_syntax_error(ch)
	return None


#Fcn for measure:voltage subsystem
def fcn_measure_voltage_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered measure:voltage subsystem")

	command_flag = 0	#Flag that checks if all commands given are correct
	for index in xrange(1, command_count):
		if not (voltage_bool(commands[index], 011) or scalar_bool(commands[index], 011) or dc_bool(commands[index], 011)):	#Only enter if incorrect commands.
			err_syntax_error(ch)
			return None

	if parameter_count == 0:
		return measure_voltage(ch, channel_count)
	else:
		err_wrong_number_of_parameters(parameter_count, 0, ch)
		return None



####################################################################################################
# Output subsystem fcns
####################################################################################################

#Fcn for output subsystem
def cmd_Output():	#NOTE! command "OUTPut?" not implemented
	print("Entered output subsystem")

	data1 = COMMAND_RECEIVED.upper().split(":")
	print("data1:", data1)

	if data1[0] == "":
		data1 = data1[1:]

	command_count = 0	#check the number of elements in data (number of "commands")
	for elements in data1:
		command_count += 1

	data2 = data1[command_count-1].split(" ")	#Split last element in data in case a parameter was given
	print("data2:", data2)
	data1 = data1[:(command_count-1)]	#Erase last element from data1
	print("new data1:", data1)
	commands = data1 + data2[:1]	#... and replace it with the first element of data 2. This way we omitt all parameters.
	parameters = data2[1:]	#Save the parameters in another variable
	print("commands:", commands)
	
	parameter_count = 0	#Count number of given parameters
	for elements in parameters:
		parameter_count += 1
		
	if parameter_count == 1:
		parameters = parameters[0].split(",")	#Parameters can also be separated by commas
		
		parameter_count = 0	#Count number of given parameters again
		for elements in parameters:
			parameter_count += 1
	
	print("parameters:", parameters)

	#Read which channel we look at:
	data3 = [commands[0].split("T"), commands[0].split("P")]
	print("data3:", data3)
	command = [data3[0][0] + "T" + data3[0][1] + "T", data3[1][0] + "P"]
	print("first command list:", command)


	for i in xrange(0, 2):
		if output_bool(command[i], 001):
			channel = data3[i][-1].split(",")
			print("channel:", channel)

			channel_count = 0	#check the number of elements in channel
			for elements in channel:
				channel_count += 1

			counter = 0
			ch = [0] * channel_count
			for elements in channel:
				if is_number(elements):
					if float(elements).is_integer():
						if 1 <= int(elements) <= 30:
							ch[counter] = int(elements) - 1	#Index of the parameters
							commands[0] = command[i]
						elif int(elements) == 0 and channel_count == 1:
							ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
							commands[0] = command[i]
						else:
							err_syntax_error(ch)
							return None
					else:
						err_syntax_error(ch)
						return None
				elif elements == "" and channel_count == 1:
					ch[counter] = address	#Set index to default channel
					commands[0] = command[i]
				elif elements == "ALL" and channel_count == 1:
					ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
					commands[0] = command[i]
				else:
					err_syntax_error(ch)
					return None

				counter += 1
			break

	print("The channel index is:", ch)
	print("commands:", commands)


	if output_bool(commands[0], 001):
		if polarity_bool(commands[1], 001):	#OUTP:POL
			if command_count == 2:
				if parameter_count == 1:
					return write_output_polarity(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		if polarity_bool(commands[1], 010):	#OUTP:POL?
			if command_count == 2:
				if parameter_count == 0:
					return read_output_polarity(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif protection_bool(commands[1], 001):	#OUTP:PROT
			return fcn_output_protection_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif power_bool(commands[1], 001):	#OUTP:POW
			return fcn_output_power_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif power_bool(commands[1], 010):	#OUTP:POW?
			if command_count == 2:
				if parameter_count == 0:
					return read_output_power_state(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif pon_bool(commands[1], 001):
			if command_count == 2:	#OUTP:PON
				if parameter_count == 1:
					return write_output_power_pon_state(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif state_bool(commands[2], 001):	#OUTP:PON:STAT
				if command_count == 3:
					if parameter_count == 1:
						return write_output_power_pon_state(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
			elif state_bool(commands[2], 010):	#OUTP:PON:STAT?
				if command_count == 3:
					if parameter_count == 0:
						return read_output_power_pon_state(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif pon_bool(commands[1], 010):	#OUTP:PON?
			if command_count == 2:
				if parameter_count == 0:
					return read_output_power_pon_state(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif auxilliary_bool(commands[1], 001):	#OUTP:AUX
			return fcn_output_auxilliary_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif auxilliary_bool(commands[1], 010):	#OUTP:AUX?
			if command_count == 2:
				if parameter_count == 0:
					return read_output_auxilliary_state(ch, channel_count)
	err_syntax_error(ch)
	return None


#Fcn for output:protection subsystem
def fcn_output_protection_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered output:protection subsystem")

	if clear_bool(commands[2], 001):	#OUTP:PROT:CLE
		if command_count == 3:
			if parameter_count == 0:
				return output_protection_clear(ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif foldback_bool(commands[2], 001):
		if command_count == 3:	#OUTP:PROT:FOLD
			if parameter_count == 1:
				return write_output_protection_foldback_mode(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif mode_bool(commands[3], 001):	#OUTP:PROT:FOLD:MOD
			if command_count == 4:
				if parameter_count == 1:
					return write_output_protection_foldback_mode(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif mode_bool(commands[3], 010):	#OUTP:PROT:FOLD:MOD?
			if command_count == 4:
				if parameter_count == 0:
					return read_output_protection_foldback_mode(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
		elif delay_bool(commands[3], 001):	#OUTP:PROT:FOLD:DEL
			if command_count == 4:
				if parameter_count == 1:
					return write_output_protection_foldback_delay(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif delay_bool(commands[3], 010):	#OUTP:PROT:FOLD:DEL?
			if command_count == 4:
				if parameter_count == 0:
					return read_output_protection_foldback_delay(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif foldback_bool(commands[2], 010):	#OUTP:PROT:FOLD?
		if command_count == 3:
			if parameter_count == 0:
				return read_output_protection_foldback_mode(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None

	err_syntax_error(ch)
	return None


#Fcn for output:power subsystem
def fcn_output_power_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered output:power subsystem")

	if command_count == 2:	#OUTP:POW
		if parameter_count == 1:
			return write_output_power_state(parameters[0], ch)
		else:
			err_wrong_number_of_parameters(parameter_count, 1, ch)
			return None
	elif state_bool(commands[2], 001):	#OUTP:POW:STAT
		if command_count == 3:
			if parameter_count == 1:
				return write_output_power_state(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif state_bool(commands[2], 010):	#OUTP:POW:STAT?
		if command_count == 3:
			if parameter_count == 0:
				return read_output_power_state(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif pon_bool(commands[2], 001):
		if command_count == 3:	#OUTP:POW:PON
			if parameter_count == 1:
				return write_output_power_pon_state(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif state_bool(commands[3], 001):	#OUTP:POW:PON:STAT
			if command_count == 4:
				if parameter_count == 1:
					return write_output_power_pon_state(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif state_bool(commands[3], 010):	#OUTP:POW:PON:STAT?
			if command_count == 4:
				if parameter_count == 0:
					return read_output_power_pon_state(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif pon_bool(commands[2], 010):	#OUTP:POW:PON?
		if command_count == 3:
			if parameter_count == 0:
				return read_output_power_pon_state(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None

	err_syntax_error(ch)
	return None


#Fcn for output:auxilliary subsystem
def fcn_output_auxilliary_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered output:auxilliary subsystem")

	if command_count == 2:	#OUTP:AUX
		if parameter_count == 1:
			return write_output_auxilliary_state(parameters[0], ch)
		else:
			err_wrong_number_of_parameters(parameter_count, 1, ch)
			return None
	elif state_bool(commands[2], 001):	#OUTP:AUX:STAT
		if command_count == 3:
			if parameter_count == 1:
				return write_output_auxilliary_state(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif state_bool(commands[2], 010):	#OUTP:AUX:STAT?
		if command_count == 3:
			if parameter_count == 0:
				return read_output_auxilliary_state(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif pon_bool(commands[2], 001):
		if command_count == 3:	#OUTP:AUX:PON
			if parameter_count == 1:
				return write_output_auxilliary_pon_state(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif state_bool(commands[3], 001):	#OUTP:AUX:PON:STAT
			if command_count == 4:
				if parameter_count == 1:
					return write_output_auxilliary_pon_state(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif state_bool(commands[3], 010):	#OUTP:AUX:PON:STAT?
			if command_count == 4:
				if parameter_count == 0:
					return read_output_auxilliary_pon_state(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif pon_bool(commands[2], 010):	#OUTP:AUX:PON?
		if command_count == 3:
			if parameter_count == 0:
				return read_output_auxilliary_pon_state(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None

	err_syntax_error(ch)
	return None



####################################################################################################
# System subsystem fcns
####################################################################################################

#Fcn for system subsystem:
def cmd_System():
	print("Entered system subsystem")
	
	data1 = COMMAND_RECEIVED.upper().split(":")
	print("data1:", data1)

	if data1[0] == "":
		data1 = data1[1:]

	command_count = 0	#check the number of elements in data (number of "commands")
	for elements in data1:
		command_count += 1

	data2 = data1[command_count-1].split(" ")	#Split last element in data in case a parameter was given
	print("data2:", data2)
	data1 = data1[:(command_count-1)]	#Erase last element from data1
	print("new data1:", data1)
	commands = data1 + data2[:1]	#... and replace it with the first element of data 2. This way we omitt all parameters.
	parameters = data2[1:]	#Save the parameters in another variable
	print("commands:", commands)
	
	parameter_count = 0	#Count number of given parameters
	for elements in parameters:
		parameter_count += 1
		
	if parameter_count == 1:
		parameters = parameters[0].split(",")	#Parameters can also be separated by commas
		
		parameter_count = 0	#Count number of given parameters again
		for elements in parameters:
			parameter_count += 1
	
	print("parameters:", parameters)

	#Read which channel we look at:
	data3 = [commands[0].split("M"), commands[0].split("T")]
	print("data3:", data3)
	command = [data3[0][0] + "M", data3[1][0] + "T"]
	print("first command list:", command)


	for i in xrange(0, 2):
		if system_bool(command[i], 001):
			channel = data3[i][-1].split(",")
			print("channel:", channel)

			channel_count = 0	#check the number of elements in channel
			for elements in channel:
				channel_count += 1

			counter = 0
			ch = [0] * channel_count
			for elements in channel:
				if is_number(elements):
					if float(elements).is_integer():
						if 1 <= int(elements) <= 30:
							ch[counter] = int(elements) - 1	#Index of the parameters
							commands[0] = command[i]
						elif int(elements) == 0 and channel_count == 1:
							ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
							commands[0] = command[i]
						else:
							err_syntax_error(ch)
							return None
					else:
						err_syntax_error(ch)
						return None
				elif (elements == "" or elements == TERMINATOR) and channel_count == 1:
					ch[counter] = address	#Set index to default channel
					commands[0] = command[i]
				elif elements == "ALL" and channel_count == 1:
					ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
					commands[0] = command[i]
				else:
					err_syntax_error(ch)
					return None

				counter += 1
			break

	print("The channel index is:", ch)
	print("commands:", commands)
	
	if system_bool(commands[0], 001):
		if fpanel_bool(commands[1], 001):
			if command_count == 2:	#SYST:FPAN
				if parameter_count == 1:
					return write_system_fpanel_timeout(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif timeout_bool(commands[2], 001):	#SYST:FPAN:TIM
				if command_count == 3:
					if parameter_count == 1:
						return write_system_fpanel_timeout(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
			elif timeout_bool(commands[2], 010): #SYST:FPAN:TIM?
				if command_count == 3:
					if parameter_count == 0:
						return read_system_fpanel_timeout(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif fpanel_bool(commands[1], 010):	#SYST:FPAN?
			if command_count == 2:
				if parameter_count == 0:
					return read_system_fpanel_timeout(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif reset_bool(commands[1], 001):	#SYST:RES
			if command_count == 2:
				if parameter_count == 0:
					return system_reset(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif wait_bool(commands[1], 001):	#SYST:WAIT
			if command_count == 2:
				if parameter_count == 0:
					return system_wait(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif test_bool(commands[1], 010):	#SYST:TEST?
			if command_count == 2:
				if parameter_count == 0:
					return read_system_test(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif identify_bool(commands[1], 010):	#SYST:IDEN?
			if command_count == 2:
				if parameter_count == 0:
					return read_system_id(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif save_bool(commands[1], 001):	#SYST:SAVE
			if command_count == 2:
				if parameter_count == 1:
					return system_save(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif recall_bool(commands[1], 001):	#SYST:REC
			if command_count == 2:
				if parameter_count == 1:
					return system_recall(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif error_bool(commands[1], 001):	#SYST:ERR
			return fcn_system_error_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif error_bool(commands[1], 010):	#SYST:ERR?
			if command_count == 2:
				if parameter_count == 0:
					return read_system_error(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif communicate_bool(commands[1], 001):	#SYST:COMM
			return fcn_system_communicate_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif remote_bool(commands[1], 001):	#SYST:REM
			return fcn_system_remote_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif pon_bool(commands[1], 001):	#SYST:PON
			return fcn_system_pon_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif version_bool(commands[1], 010):	#SYST:VERS
			if command_count == 2:
				if parameter_count == 0:
					return read_system_version(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif help_bool(commands[1], 001):
			if headers_bool(commands[2], 010):	#SYST:HELP:HEAD?
				if command_count == 3:
					if parameter_count == 0:
						return read_system_help_header(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
			elif legacy_bool(commands[2], 010):	#SYST:HELP:LEG?
				if command_count == 3:
					if parameter_count == 0:
						return read_system_help_legacy(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif help_bool(commands[1], 010):	#SYST:HELP?
			if command_count == 2:
				if parameter_count == 0:
					return read_system_help_header(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif protection_bool(commands[1], 001):
			if command_count == 2:	#SYST:PROT
				if parameter_count == 1:
					return write_system_protection_mask(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			if mask_bool(commands[2], 001):	#SYST:PROT:MASK
				if command_count == 3:
					if parameter_count == 1:
						return write_system_protection_mask(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
			elif mask_bool(commands[2], 010):	#SYST:PROT:MASK?
				if command_count == 3:
					if parameter_count == 0:
						return read_system_protection_mask(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
			if latch_bool(commands[2], 001):	#SYST:PROT:LAT
				if command_count == 3:
					if parameter_count == 1:
						return write_system_protection_latch(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
			elif latch_bool(commands[2], 010):	#SYST:PROT:LAT?
				if command_count == 3:
					if parameter_count == 0:
						return read_system_protection_latch(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif protection_bool(commands[1], 010):	#SYST:PROT?
			if command_count == 2:
				if parameter_count == 0:
					return read_system_protection_mask(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
					
	err_syntax_error(ch)
	return None
		
		
#Fcn for system:error subsystem
def fcn_system_error_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered system:error subsystem")
	
	if command_count == 2:
		err_syntax_error(ch)
		return None
	if next_bool(commands[2], 010):	#SYST:ERR:NEXT
		if command_count == 3:
				if parameter_count == 0:
					return read_system_error(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif code_bool(commands[2], 010):
		if command_count == 3:	#SYST:ERR:CODE
			if parameter_count == 0:
				return read_system_error_code(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
		elif next_bool(commands[3], 010):	#SYST:ERR:CODE:NEXT
			if command_count == 4:	
				if parameter_count == 0:
					return read_system_error_code(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif count_bool(commands[2], 010):	#SYST:ERR:COUNT
		if command_count == 3:
			if parameter_count == 0:
				return read_system_error_count(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	
	err_syntax_error(ch)
	return None
				

#Fcn for system:communicate subsystem
def fcn_system_communicate_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered system:communicate subsystem")
	
	if aprogram_bool(commands[2], 001):
		if source_optional_commands(commands[3], 0000001):
			if command_count == 4:	#SYST:COMM:APR:LEV
				if parameter_count == 1:
					return write_system_apg_voltage(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif voltage_bool(commands[4], 001):	#SYST:COMM:APR:LEV:VOLT
				if command_count == 5:
					if parameter_count == 1:
						return write_system_apg_voltage(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
				elif isolated_bool(commands[5], 001):	#SYST:COMM:APR:LEV:VOLT:ISOL
					if command_count == 6:
						if parameter_count == 1:
							return write_system_apg_voltage(parameters[0], ch)
						else:
							err_wrong_number_of_parameters(parameter_count, 1, ch)
							return None
				elif isolated_bool(commands[5], 010):	#SYST:COMM:APR:LEV:VOLT:ISOL?
					if command_count == 6:
						if parameter_count == 0:
							return read_system_apg_voltage(ch, channel_count)
						else:
							err_wrong_number_of_parameters(parameter_count, 0, ch)
							return None
			elif voltage_bool(commands[4], 010):	#SYST:COMM:APR:LEV:VOLT?
				if command_count == 5:
					if parameter_count == 0:
						return read_system_apg_voltage(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
			elif current_bool(commands[4], 001):	#SYST:COMM:APR:LEV:CURR
				if command_count == 5:
					if parameter_count == 1:
						return write_system_apg_current(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
				elif isolated_bool(commands[5], 001):	#SYST:COMM:APR:LEV:CURR:ISOL
					if command_count == 6:
						if parameter_count == 1:
							return write_system_apg_current(parameters[0], ch)
						else:
							err_wrong_number_of_parameters(parameter_count, 1, ch)
							return None
				elif isolated_bool(commands[5], 010):	#SYST:COMM:APR:LEV:CURR:ISOL?
					if command_count == 6:
						if parameter_count == 0:
							return read_system_apg_current(ch, channel_count)
						else:
							err_wrong_number_of_parameters(parameter_count, 0, ch)
							return None
			elif current_bool(commands[4], 010):	#SYST:COMM:APR:LEV:CURR?
				if command_count == 5:
					if parameter_count == 0:
						return read_system_apg_current(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif source_optional_commands(commands[3], 0001000):	#SYST:COMM:APR:LEV?
			if command_count == 4:
				if parameter_count == 0:
					return read_system_apg_voltage(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif mchannel_bool(commands[2], 001):
		if address_bool(commands[3], 001):	#SYST:COMM:MCH:ADD
			if command_count == 4:
				if parameter_count == 1:
					return write_system_address(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif address_bool(commands[3], 010):	#SYST:COMM:MCH:ADD?
			if command_count == 4:
				if parameter_count == 0:
					return read_system_address(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif address_bool(commands[2], 001):	#SYST:COMM:ADD
		if command_count == 3:
			if parameter_count == 1:
				return write_system_address(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif address_bool(commands[2], 010):	#SYST:COMM:ADD?
		if command_count == 3:
			if parameter_count == 0:
				return read_system_address(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
				
	err_syntax_error(ch)
	return None
							
							
#Fcn for system:remote subsystem
def fcn_system_remote_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered system:remote subsystem")
	
	if source_bool(commands[2], 001):
		if command_count == 3:	#SYST:REM:SOUR
			if parameter_count == 1:
				return write_system_remote_voltage(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif voltage_bool(commands[3], 001):	#SYST:REM:SOUR:VOLT
			if command_count == 4:
				if parameter_count == 1:
					return write_system_remote_voltage(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif voltage_bool(commands[3], 010):	#SYST:REM:SOUR:VOLT?
			if command_count == 4:
				if parameter_count == 0:
					return read_system_remote_voltage(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif current_bool(commands[3], 001):	#SYST:REM:SOUR:CURR
			if command_count == 4:
				if parameter_count == 1:
					return write_system_remote_current(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif current_bool(commands[3], 010):	#SYST:REM:SOUR:CURR?
			if command_count == 4:
				if parameter_count == 0:
					return read_system_remote_current(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif source_bool(commands[2], 010):	#SYST:REM:SOUR?
		if command_count == 3:
			if parameter_count == 0:
				return read_system_remote_voltage(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif state_bool(commands[2], 001):	#SYST:REM:STAT
		if command_count == 3:
			if parameter_count == 1:
				return write_system_remote_state(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif state_bool(commands[2], 010):	#SYST:REM:STAT?
		if command_count == 3:
			if parameter_count == 0:
				return read_system_remote_state(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
				
	err_syntax_error(ch)
	return None
				
				
#Fcn for system:pon subsystem
def fcn_system_pon_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered system:pon subsystem")
	
	if voltage_bool(commands[2], 001):	#SYST:PON:VOLT
		if command_count == 3:
			if parameter_count == 1:
				return write_system_pon_voltage(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif voltage_bool(commands[2], 010):	#SYST:PON:VOLT?
		if command_count == 3:
			if parameter_count == 0:
				return read_system_pon_voltage(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif current_bool(commands[2], 001):	#SYST:PON:CURR
		if command_count == 3:
			if parameter_count == 1:
				return write_system_pon_current(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif current_bool(commands[2], 010):	#SYST:PON:CURR?
		if command_count == 3:
			if parameter_count == 0:
				return read_system_pon_current(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif enable_bool(commands[2], 001):
		if voltage_bool(commands[3], 001):	#SYST:PON:ENA:VOLT
			if command_count == 4:
				if parameter_count == 1:
					return write_system_pon_enable_voltage(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif voltage_bool(commands[3], 010):	#SYST:PON:ENA:VOLT?
			if command_count == 4:
				if parameter_count == 0:
					return read_system_pon_enable_voltage(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif current_bool(commands[3], 001):	#SYST:PON:ENA:CURR
			if command_count == 4:
				if parameter_count == 1:
					return write_system_pon_enable_current(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif current_bool(commands[3], 010):	#SYST:PON:ENA:CURR?
			if command_count == 4:
				if parameter_count == 0:
					return read_system_pon_enable_current(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
					
	err_syntax_error(ch)
	return None
	
	
							
####################################################################################################						
# Status subsystem fcns
####################################################################################################

#Fcn for status subsystem:
def cmd_Status():
	print("Entered status subsystem")
	
	data1 = COMMAND_RECEIVED.upper().split(":")
	print("data1:", data1)

	if data1[0] == "":
		data1 = data1[1:]

	command_count = 0	#check the number of elements in data (number of "commands")
	for elements in data1:
		command_count += 1

	data2 = data1[command_count-1].split(" ")	#Split last element in data in case a parameter was given
	print("data2:", data2)
	data1 = data1[:(command_count-1)]	#Erase last element from data1
	print("new data1:", data1)
	commands = data1 + data2[:1]	#... and replace it with the first element of data 2. This way we omitt all parameters.
	parameters = data2[1:]	#Save the parameters in another variable
	print("commands:", commands)
	
	parameter_count = 0	#Count number of given parameters
	for elements in parameters:
		parameter_count += 1
		
	if parameter_count == 1:
		parameters = parameters[0].split(",")	#Parameters can also be separated by commas
		
		parameter_count = 0	#Count number of given parameters again
		for elements in parameters:
			parameter_count += 1
	
	print("parameters:", parameters)

	#Read which channel we look at:
	data3 = [commands[0].split("S"), commands[0].split("T")]
	print("data3:", data3)
	command = ["S" + data3[0][1] + "S", data3[1][0] + "T" + data3[1][1] + "T"]
	print("first command list:", command)


	for i in xrange(0, 2):
		if status_bool(command[i], 001):
			channel = data3[i][-1].split(",")
			print("channel:", channel)

			channel_count = 0	#check the number of elements in channel
			for elements in channel:
				channel_count += 1

			counter = 0
			ch = [0] * channel_count
			for elements in channel:
				if is_number(elements):
					if float(elements).is_integer():
						if 1 <= int(elements) <= 30:
							ch[counter] = int(elements) - 1	#Index of the parameters
							commands[0] = command[i]
						elif int(elements) == 0 and channel_count == 1:
							ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
							commands[0] = command[i]
						else:
							err_syntax_error(ch)
							return None
					else:
						err_syntax_error(ch)
						return None
				elif (elements == "" or elements == TERMINATOR) and channel_count == 1:
					ch[counter] = address	#Set index to default channel
					commands[0] = command[i]
				elif elements == "ALL" and channel_count == 1:
					ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
					commands[0] = command[i]
				else:
					err_syntax_error(ch)
					return None

				counter += 1
			break

	print("The channel index is:", ch)
	print("commands:", commands)
	
	if status_bool(commands[0], 001):
		if operation_bool(commands[1], 001):	#STAT:OPER
			return fcn_status_operation_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif operation_bool(commands[1], 010):	#STAT:OPER?
			if command_count == 2:
				if parameter_count == 0:
					return read_status_operation_event(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif preset_bool(commands[1], 001):	#STAT:PRES
			if command_count == 2:
				if parameter_count == 0:
					return status_preset(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif questionable_bool(commands[1], 001):	#STAT:QUES
			return fcn_status_questionable_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif questionable_bool(commands[1], 010):	#STAT:QUES?
			if command_count == 2:
				if parameter_count == 0:
					return read_status_questionable_event(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif standard_bool(commands[1], 001):
			if event_bool(commands[2], 010):	#STAT:STAN:EVEN?
				if command_count == 3:
					if parameter_count == 0:
						return read_status_standard_event(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count ,0, ch)
						return None
			elif enable_bool(commands[2], 001):	#STAT:STAN:ENAB
				if command_count == 3:
					if parameter_count == 1:
						return write_status_standard_enable(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
			elif enable_bool(commands[2], 010):	#STAT:STAN:ENAB?
				if command_count == 3:
					if parameter_count == 0:
						return read_status_standard_enable(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif standard_bool(commands[1], 010):	#STAT:STAN?
			if command_count == 2:
				if parameter_count == 0:
					return read_status_standard_event(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif sbyte_bool(commands[1], 001):
			if event_bool(commands[2], 010):	#STAT:SBYT:EVEN?
				if command_count == 3:
					if parameter_count == 0:
						return read_status_sbyte_event(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif sbyte_bool(commands[1], 010):	#STAT:SBYT?
			if command_count == 2:
				if parameter_count == 0:
					return read_status_sbyte_event(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif srequest_bool(commands[1], 001):
			if command_count == 2:	#STAT:SREQ
				if parameter_count == 1:
					return write_status_srequest_enable(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif enable_bool(commands[2], 001):	#STAT:SREQ:ENAB
				if command_count == 3:
					if parameter_count == 1:
						return write_status_srequest_enable(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
			elif enable_bool(commands[2], 010):	#STAT:SREQ:ENAB?
				if command_count == 3:
					if parameter_count == 0:
						return read_status_srequest_enable(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif srequest_bool(commands[1], 010):	#STAT:SREQ?
			if command_count == 2:
				if parameter_count == 0:
					return read_status_srequest_enable(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif clear_bool(commands[1], 001):	#STAT:CLEAR
			if command_count == 2:
				if parameter_count == 0:
					return status_clear(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
				
	err_syntax_error(ch)
	return None
	

#Fcn for status:operation subsystem
def fcn_status_operation_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered status:operation subsystem")
	
	if condition_bool(commands[2], 010):	#STAT:OPER:COND
		if command_count == 3:
			if parameter_count == 0:
				return read_status_operation_condition(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif enable_bool(commands[2], 001):	#STAT:OPER:ENAB
		if command_count == 3:
			if parameter_count == 1:
				return write_status_operation_enable(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif enable_bool(commands[2], 010):	#STAT:OPER:ENAB?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_operation_enable(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif event_bool(commands[2], 010):	#STAT:OPER:EVEN?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_operation_event(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif ntransition_bool(commands[2], 001):	#STAT:OPER:NTR
		if command_count == 3:
			if parameter_count == 1:
				return write_status_operation_ntransition(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif ntransition_bool(commands[2], 010):	#STAT:OPER:NTR?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_operation_ntransition(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif ptransition_bool(commands[2], 001):	#STAT:OPER:PTR
		if command_count == 3:
			if parameter_count == 1:
				return write_status_operation_ptransition(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif ptransition_bool(commands[2], 010):	#STAT:OPER:PTR?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_operation_ptransition(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif shutdown_bool(commands[2], 001):
		if condition_bool(commands[3], 010):	#STAT:OPER:SHUT:COND?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_shutdown_condition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif enable_bool(commands[3], 001):	#STAT:OPER:SHUT:ENAB
			if command_count == 4:
				if parameter_count == 1:
					return write_status_operation_shutdown_enable(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif enable_bool(commands[3], 010):	#STAT:OPER:SHUT:ENAB?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_shutdown_enable(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif event_bool(commands[3], 010):	#STAT:OPER:SHUT:EVEN?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_shutdown_event(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif ntransition_bool(commands[3], 001):	#STAT:OPER:SHUT:NTR
			if command_count == 4:
				if parameter_count == 1:
					return write_status_operation_shutdown_ntranstion(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif ntransition_bool(commands[3], 010):	#STAT:OPER:SHUT:NTR?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_shutdown_ntransition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif ptransition_bool(commands[3], 001):	#STAT:OPER:SHUT:PTR
			if command_count == 4:
				if parameter_count == 1:
					return write_status_operation_shutdown_ptranstion(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif ptransition_bool(commands[3], 010):	#STAT:OPER:SHUT:PTR?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_shutdown_ptransition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif protection_bool(commands[3], 001):
			if condition_bool(commands[4], 010):	#STAT:OPER:SHUT:PROT:COND?
				if command_count == 5:
					if parameter_count == 0:
						return read_status_operation_shutdown_protection_condition(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
			elif enable_bool(commands[4], 001):	#STAT:OPER:SHUT:PROT:ENAB
				if command_count == 5:
					if parameter_count == 1:
						return write_status_operation_shutdown_protection_enable(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
			elif enable_bool(commands[4], 010):	#STAT:OPER:SHUT:PROT:ENAB?
				if command_count == 5:
					if parameter_count == 0:
						return read_status_operation_shutdown_protection_enable(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
			elif event_bool(commands[4], 010):	#STAT:OPER:SHUT:PROT:EVEN?
				if command_count == 5:
					if parameter_count == 0:
						return read_status_operation_shutdown_protection_event(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
			elif ntransition_bool(commands[4], 001):	#STAT:OPER:SHUT:PROT:NTR
				if command_count == 5:
					if parameter_count == 1:
						return write_status_operation_shutdown_protection_ntranstion(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
			elif ntransition_bool(commands[4], 010):	#STAT:OPER:SHUT:PROT:NTR?
				if command_count == 5:
					if parameter_count == 0:
						return read_status_operation_shutdown_protection_ntransition(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
			elif ptransition_bool(commands[4], 001):	#STAT:OPER:SHUT:PROT:PTR
				if command_count == 5:
					if parameter_count == 1:
						return write_status_operation_shutdown_protection_ptranstion(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
			elif ptransition_bool(commands[4], 010):	#STAT:OPER:SHUT:PROT:PTR?
				if command_count == 5:
					if parameter_count == 0:
						return read_status_operation_shutdown_protection_ptransition(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif protection_bool(commands[3], 010):	#STAT:OPER:SHUT:PROT?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_shutdown_protection_event(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count ,0, ch)
					return None
	elif shutdown_bool(commands[2], 010):	#STAT:OPER:SHUT?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_operation_shutdown_event(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif cshare_bool(commands[2], 001):
		if event_bool(commands[3], 010):	#STAT:OPER:CSH:EVEN?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_cshare_event(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif enable_bool(commands[3], 001):	#STAT:OPER:CSH:ENAB
			if command_count == 4:
				if parameter_count == 1:
					return write_status_operation_cshare_enable(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif enable_bool(commands[3], 010):	#STAT:OPER:CSH:ENAB?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_cshare_enable(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif condition_bool(commands[3], 010):	#STAT:OPER:CSH:COND?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_cshare_condition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif ptransition_bool(commands[3], 001):	#STAT:OPER:CSH:PTR
			if command_count == 4:
				if parameter_count == 1:
					return write_status_operation_cshare_ptransitions(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif ptransition_bool(commands[3], 010):	#STAT:OPER:CSH:PTR?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_cshare_ptransition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif ntransition_bool(commands[3], 001):	#STAT:OPER:CSH:NTR
			if command_count == 4:
				if parameter_count == 1:
					return write_status_operation_cshare_ntransitions(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif ntransition_bool(commands[3], 010):	#STAT:OPER:CSH:NTR?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_operation_cshare_ntransition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif cshare_bool(commands[2], 010):	#STAT:OPER:CSH?
			if command_count == 3:
				if parameter_count == 0:
					return read_status_operation_cshare_event(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
					
	err_syntax_error(ch)
	return None
	
	
#Fcn for status:questionable subsystem
def fcn_status_questionable_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered status:questionable subsystem")
	
	if event_bool(commands[2], 010):	#STAT:QUES:EVEN?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_questionable_event(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif enable_bool(commands[2], 001):	#STAT:QUES:ENAB
		if command_count == 3:
			if parameter_count == 1:
				return write_status_questionable_enable(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif enable_bool(commands[2], 010):	#STAT:QUES:ENAB?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_questionable_enable(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif condition_bool(commands[2], 010):	#STAT:QUES:COND?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_questionable_condition(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif ntransition_bool(commands[2], 001):	#STAT:QUES:NTR
		if command_count == 3:
			if parameter_count == 1:
				return write_status_questionable_ntransition(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif ntransition_bool(commands[2], 010):	#STAT:QUES:NTR?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_questionable_ntransition(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif ptransition_bool(commands[2], 001):	#STAT:QUES:PTR
		if command_count == 3:
			if parameter_count == 1:
				return write_status_questionable_ptransition(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif ptransition_bool(commands[2], 010):	#STAT:QUES:PTR?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_questionable_ptransition(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif temperature_bool(commands[2], 001):
		if event_bool(commands[3], 010):	#STAT:QUES:TEMP:EVEN?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_questionable_temperature_event(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif enable_bool(commands[3], 001):	#STAT:QUES:TEMP:ENAB
			if command_count == 4:
				if parameter_count == 1:
					return write_status_questionable_temperature_enable(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif enable_bool(commands[3], 010):	#STAT:QUES:TEMP:ENAB?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_questionable_temperature_enable(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif condition_bool(commands[3], 010):	#STAT:QUES:TEMP:COND?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_questionable_temperature_condition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif ntransition_bool(commands[3], 001):	#STAT:QUES:TEMP:NTR
			if command_count == 4:
				if parameter_count == 1:
					return write_status_questionable_temperature_ntransition(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif ntransition_bool(commands[3], 010):	#STAT:QUES:TEMP:NTR?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_questionable_temperature_ntransition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif ptransition_bool(commands[3], 001):	#STAT:QUES:TEMP:PTR
			if command_count == 4:
				if parameter_count == 1:
					return write_status_questionable_temperature_ptransition(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif ptransition_bool(commands[3], 010):	#STAT:QUES:TEMP:PTR?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_questionable_temperature_ptransition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif temperature_bool(commands[2], 010):	#STAT:QUES:TEMP?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_questionable_temperature_event(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif voltage_bool(commands[2], 001):
		if event_bool(commands[3], 010):	#STAT:QUES:VOLT:EVEN?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_questionable_voltage_event(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif enable_bool(commands[3], 001):	#STAT:QUES:VOLT:ENAB
			if command_count == 4:
				if parameter_count == 1:
					return write_status_questionable_voltage_enable(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif enable_bool(commands[3], 010):	#STAT:QUES:VOLT:ENAB?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_questionable_voltage_enable(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif condition_bool(commands[3], 010):	#STAT:QUES:VOLT:COND?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_questionable_voltage_condition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif ntransition_bool(commands[3], 001):	#STAT:QUES:VOLT:NTR
			if command_count == 4:
				if parameter_count == 1:
					return write_status_questionable_voltage_ntransition(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif ntransition_bool(commands[3], 010):	#STAT:QUES:VOLT:NTR?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_questionable_voltage_ntransition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif ptransition_bool(commands[3], 001):	#STAT:QUES:VOLT:PTR
			if command_count == 4:
				if parameter_count == 1:
					return write_status_questionable_voltage_ptransition(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif ptransition_bool(commands[3], 010):	#STAT:QUES:VOLT:PTR?
			if command_count == 4:
				if parameter_count == 0:
					return read_status_questionable_voltage_ptransition(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif voltage_bool(commands[2], 010):	#STAT:QUES:VOLT?
		if command_count == 3:
			if parameter_count == 0:
				return read_status_questionable_voltage_event(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
				
	err_syntax_error(ch)
	return None



####################################################################################################
# Calibration subsystem fcns
####################################################################################################

#Fcn for calibration subsystem:
def cmd_Calibration():
	print("Entered calibration subystem")

	data1 = COMMAND_RECEIVED.upper().split(":")
	print("data1:", data1)

	if data1[0] == "":
		data1 = data1[1:]

	command_count = 0	#check the number of elements in data (number of "commands")
	for elements in data1:
		command_count += 1

	data2 = data1[command_count-1].split(" ")	#Split last element in data in case a parameter was given
	print("data2:", data2)
	data1 = data1[:(command_count-1)]	#Erase last element from data1
	print("new data1:", data1)
	commands = data1 + data2[:1]	#... and replace it with the first element of data 2. This way we omitt all parameters.
	parameters = data2[1:]	#Save the parameters in another variable
	print("commands:", commands)
	
	parameter_count = 0	#Count number of given parameters
	for elements in parameters:
		parameter_count += 1
		
	if parameter_count == 1:
		parameters = parameters[0].split(",")	#Parameters can also be separated by commas
		
		parameter_count = 0	#Count number of given parameters again
		for elements in parameters:
			parameter_count += 1
	
	print("parameters:", parameters)

	#Read which channel we look at:
	data3 = [commands[0].split("L"), commands[0].split("N")]
	print("data3:", data3)
	command = [data3[0][0] + "L", data3[1][0] + "N"]
	print("first command list:", command)

	for i in xrange(1,-1,-1):	#Need to go backwards since
		if calibration_bool(command[i], 001):
			channel = data3[i][1].split(",")
			print("channel:", channel)

			channel_count = 0	#check the number of elements in channel
			for elements in channel:
				channel_count += 1

			counter = 0
			ch = [0] * channel_count
			for elements in channel:
				if is_number(elements):
					if float(elements).is_integer():
						if 1 <= int(elements) <= 30:
							ch[counter] = int(elements) - 1	#Index of the parameters
							commands[0] = command[i]
						elif int(elements) == 0 and channel_count == 1:
							ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
							commands[0] = command[i]
						else:
							err_syntax_error("ALL")
							return None
					else:
						err_syntax_error("ALL")
						return None
				elif elements == "" and channel_count == 1:
					ch[counter] = address	#Set index to default channel
					commands[0] = command[i]
				elif (data3[1][0] == "CALALL" or elements == "ALL") and channel_count == 1:
					ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
					commands[0] = command[i]
				else:
					err_syntax_error("ALL")
					return None

				counter += 1
			break

	print("The channel index is:", ch)
	print("commands:", commands)


	if calibration_bool(commands[0], 001):
		if input_bool(commands[1], 001):
			return fcn_calibration_input_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif output_bool(commands[1], 001):
			return fcn_calibration_output_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif monitor_bool(commands[1], 001):
			return fcn_calibration_monitor_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count)
		elif monitor_bool(commands[1], 010):
			if command_count == 2:
				if parameter_count == 0:
					return read_calibration_monitor_voltage(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif store_bool(commands[1], 001):	#CAL:STOR
			if command_count == 2:
				if parameter_count == 0:
					return store_calibration(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif restore_bool(commands[1], 001):	#CAL:REST
			if command_count == 2:
				if parameter_count == 0:
					return restore_calibration(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif default_bool(commands[1], 001):	#CAL:DEF
			if command_count == 2:
				if parameter_count == 0:
					return default_calibration(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif voltage_bool(commands[1], 001):
			if protection_bool(commands[2], 001):
				if command_count == 3:	#CAL:VOLT:PROT
					if  parameter_count == 1:
						return write_calibration_voltage_protection(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
				elif over_bool(commands[3], 001):	#CAL:VOLT:PROT:OVER
					if command_count == 4:
						if  parameter_count == 1:
							return write_calibration_voltage_protection(parameters[0], ch)
						else:
							err_wrong_number_of_parameters(parameter_count, 1, ch)
							return None
		elif protection_bool(commands[1], 001):
			if command_count == 2:	#CAL:PROT
				if  parameter_count == 1:
					return write_calibration_voltage_protection(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif over_bool(commands[2], 001):	#CAL:PROT:OVER
				if command_count == 3:
					if  parameter_count == 1:
						return write_calibration_voltage_protection(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None

	err_syntax_error(ch)
	return None


#Fcn for calibration:input subsystem
def fcn_calibration_input_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered calibration input subsystem")

	if command_count == 3:
		if analog_bool(commands[2], 001):	#CAL:INP:ANAL
			if parameter_count == 1:
				return write_calibration_input_analog_voltage(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif analog_bool(commands[2], 010):	#CAL:INP:ANAL?
			if parameter_count == 0:
				return read_calibration_input_analog_voltage(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif command_count == 4:
		if analog_bool(commands[2], 001):
			if voltage_bool(commands[3], 001):	#CAL:INP:ANAL:VOLT
				if parameter_count == 1:
					return write_calibration_input_analog_voltage(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif voltage_bool(commands[2], 010):	#CAL:INP:ANAL:VOLT?
				if parameter_count == 0:
					return read_calibration_input_analog_voltage(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
			elif current_bool(commands[3], 001):	#CAL:INP:ANAL:CURR
				if parameter_count == 1:
					return write_calibration_input_analog_current(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif current_bool(commands[2], 010):	#CAL:INP:ANAL:CURR?
				if parameter_count == 0:
					return read_calibration_input_analog_current(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None

	err_syntax_error(ch)
	return None


#Fcn for calibration:output subsystem
def fcn_calibration_output_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered calibration output subsystem")

	if command_count == 2:	#CAL:OUTP
		if parameter_count == 1:
			return write_calibration_output_voltage(parameters[0], ch)
		else:
			err_wrong_number_of_parameters(parameter_count, 1, ch)
			return None
	elif command_count == 3:
		if current_bool(commands[2], 001):	#CAL:OUTP:CURR
			if parameter_count == 1:
				return write_calibration_output_current(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif voltage_bool(commands[2], 001):	#CAL:OUTP:VOLT
			if parameter_count == 1:
				return write_calibration_output_voltage(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif analog_bool(commands[2], 001):	#CAL:OUTP:ANAL
			if parameter_count == 1:
				return write_calibration_output_voltage_analog(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
		elif analog_bool(commands[2], 010):	#CAL:OUTP:ANAL?
			if parameter_count == 0:
				return read_calibration_output_voltage_analog(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif command_count == 4:
		if analog_bool(commands[2], 001):
			if voltage_bool(commands[3], 001):	#CAL:OUTP:ANAL:VOLT
				if parameter_count == 1:
					return write_calibration_output_voltage_analog(parameters[0], ch)
				elif parameter_count == 0:
					return write_calibration_output_voltage_analog_interactive(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
			elif voltage_bool(commands[3], 010):	#CAL:OUTP:ANAL:VOLT?
				if parameter_count == 0:
					return read_calibration_output_voltage_analog(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0 ,ch)
					return None
			elif isolated_bool(commands[3], 001):	#CAL:OUTP:ANAL:ISOL
				if parameter_count == 1:
					return write_calibration_output_voltage_analog_isolated(parameters[0], ch)
				elif parameter_count == 0:
					return write_calibration_output_voltage_analog_isolated_interactive(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
			elif isolated_bool(commands[3], 010):	#CAL:OUTP:ANAL:ISOL?
				if parameter_count == 0:
					return read_calibration_output_voltage_analog_isolated(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
			elif resistive_bool(commands[3], 001):	#CAL:OUTP:ANAL:RES
				if parameter_count == 1:
					return write_calibration_output_voltage_analog_resistive(parameters[0], ch)
				elif parameter_count == 0:
					return write_calibration_output_voltage_analog_resistive_interactive(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
			elif resistive_bool(commands[3], 010):	#CAL:OUTP:ANAL:RES?
				if parameter_count == 0:
					return read_calibration_output_voltage_analog_resistive(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
			elif current_bool(commands[3], 001):	#CAL:OUTP:ANAL:CURR
				if parameter_count == 1:
					return write_calibration_output_current_analog(parameters[0], ch)
				elif parameter_count == 0:
					return write_calibration_output_current_analog_interactive(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
			elif current_bool(commands[3], 010):	#CAL:OUTP:ANAL:CURR?
				if parameter_count == 0:
					return read_calibration_output_current_analog(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif command_count == 5:
		if analog_bool(commands[2], 001):
			if voltage_bool(commands[3], 001):
				if isolated_bool(commands[4], 001):	#CAL:OUTP:ANAL:VOLT:ISOL
					if parameter_count == 1:
						return write_calibration_output_voltage_analog_isolated(parameters[0], ch)
					elif parameter_count == 0:
						return write_calibration_output_voltage_analog_isolated_interactive(ch)
					else:
						err_parameter_not_allowed(ch)
						return None
				elif isolated_bool(commands[4], 010):	#CAL:OUTP:ANAL:VOLT:ISOL?
					if parameter_count == 0:
						return read_calibration_output_voltage_analog_isolated(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
				elif resistive_bool(commands[4], 001):	#CAL:OUTP:ANAL:VOLT:RES
					if parameter_count == 1:
						return write_calibration_output_voltage_analog_resistive(parameters[0], ch)
					elif parameter_count == 0:
						return write_calibration_output_voltage_analog_resistive_interactive(ch)
					else:
						err_parameter_not_allowed(ch)
						return None
				elif resistive_bool(commands[4], 010):	#CAL:OUTP:ANAL:VOLT:RES?
					if parameter_count == 0:
						return read_calibration_output_voltage_analog_resistive(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
			elif resistive_bool(commands[3], 001):
				if isolated_bool(commands[4], 001):	#CAL:OUTP:ANAL:RES:ISOL
					if parameter_count == 1:
						return write_calibration_output_voltage_analog_resistive_isolated(parameters[0], ch)
					elif parameter_count == 0:
						return write_calibration_output_voltage_analog_resistive_isolated_interactive(ch)
					else:
						err_parameter_not_allowed(ch)
						return None
				elif isolated_bool(commands[4], 010):	#CAL:OUTP:ANAL:RES:ISOL?
					if parameter_count == 0:
						return read_calibration_output_voltage_analog_resistive_isolated(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
			elif current_bool(commands[3], 001):
				if isolated_bool(commands[4], 001):	#CAL:OUTP:ANAL:CURR:ISOL
					if parameter_count == 1:
						return write_calibration_output_current_analog_isolated(parameters[0], ch)
					elif parameter_count == 0:
						return write_calibration_output_current_analog_isolated_interactive(ch)
					else:
						err_parameter_not_allowed(ch)
						return None
				elif isolated_bool(commands[4], 010):	#CAL:OUTP:ANAL:CURR:ISOL?
					if parameter_count == 0:
						return read_calibration_output_current_analog_isolated(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
				elif resistive_bool(commands[4], 001):	#CAL:OUTP:ANAL:CURR:RES
					if parameter_count == 1:
						return write_calibration_output_current_analog_resistive(parameters[0], ch)
					elif parameter_count == 0:
						return write_calibration_output_current_analog_resistive_interactive(ch)
					else:
						err_parameter_not_allowed(ch)
						return None
				elif resistive_bool(commands[4], 010):	#CAL:OUTP:ANAL:CURR:RES?
					if parameter_count == 0:
						return read_calibration_output_current_analog_resistive(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
	elif command_count == 6:
		if analog_bool(commands[2], 001):
			if voltage_bool(commands[3], 001):
				if resistive_bool(commands[4], 001):
					if isolated_bool(commands[5], 001):	#CAL:OUTP:ANAL:VOLT:RES:ISOL
						if parameter_count == 1:
							return write_calibration_output_voltage_analog_resistive_isolated(parameters[0], ch)
						elif parameter_count == 0:
							return write_calibration_output_voltage_analog_resistive_isolated_interactive(ch)
						else:
							err_parameter_not_allowed(ch)
							return None
					elif isolated_bool(commands[5], 010):	#CAL:OUTP:ANAL:VOLT:RES:ISOL?
						if parameter_count == 0:
							return read_calibration_output_voltage_analog_resistive_isolated(ch, channel_count)
						else:
							err_wrong_number_of_parameters(parameter_count, 0, ch)
							return None
			if current_bool(commands[3], 001):
				if resistive_bool(commands[4], 001):
					if isolated_bool(commands[5], 001):	#CAL:OUTP:ANAL:CURR:RES:ISOL
						if parameter_count == 1:
							return write_calibration_output_current_analog_resistive_isolated(parameters[0], ch)
						elif parameter_count == 0:
							return write_calibration_output_current_analog_resistive_isolated_interactive(ch)
						else:
							err_parameter_not_allowed(ch)
							return None
					elif isolated_bool(commands[5], 010):	#CAL:OUTP:ANAL:CURR:RES:ISOL?
						if parameter_count == 0:
							return read_calibration_output_current_analog_resistive_isolated(ch, channel_count)
						else:
							err_wrong_number_of_parameters(parameter_count, 0, ch)
							return None

	err_syntax_error(ch)
	return None


#Fcn for calibration:monitor subsystem
def fcn_calibration_monitor_subsystem(commands, parameters, ch, command_count, parameter_count, channel_count):
	print("Entered fcn for calibration:monitor subsystem")

	if command_count == 2:	#CAL:MON
		if parameter_count == 1:
			return write_calibration_monitor_voltage(parameters[0], ch)
		if parameter_count == 0:
			return write_calibration_monitor_voltage_interactive(ch, channel_count)
		else:
			return None
	elif command_count == 3:
		if voltage_bool(commands[2], 001):	#CAL:MON:VOLT
			if parameter_count == 1:
				return write_calibration_monitor_voltage(parameters[0], ch)
			if parameter_count == 0:
				return write_calibration_monitor_voltage_interactive(ch)
			else:
				return None
		elif voltage_bool(commands[2], 010):	#CAL:MON:VOLT?
			if parameter_count == 0:
				return read_calibration_monitor_voltage(ch, channel_count)
			else:
				return None
		elif isolated_bool(commands[2], 001):	#CAL:MON:ISOL
			if parameter_count == 1:
				return write_calibration_monitor_voltage_isolated(parameters[0], ch)
			if parameter_count == 0:
				return write_calibration_monitor_voltage_isolated_interactive(ch)
			else:
				return None
		elif isolated_bool(commands[2], 010):	#CAL:MON:ISOL?
			if parameter_count == 0:
				return read_calibration_monitor_voltage_isolated(ch, channel_count)
			else:
				return None
		elif current_bool(commands[2], 001):	#CAL:MON:CURR
			if parameter_count == 1:
				return write_calibration_monitor_current(parameters[0], ch)
			if parameter_count == 0:
				return write_calibration_monitor_current_interactive(ch)
			else:
				return None
		elif current_bool(commands[2], 010):	#CAL:MON:CURR?
			if parameter_count == 0:
				return read_calibration_monitor_current(ch, channel_count)
			else:
				return None
	elif command_count == 4:
		if voltage_bool(commands[2], 001):
			if isolated_bool(commands[3], 001):	#CAL:MON:VOLT:ISOL
				if parameter_count == 1:
					return write_calibration_monitor_voltage_isolated(parameters[0], ch)
				if parameter_count == 0:
					return write_calibration_monitor_voltage_isolated_interactive(ch)
				else:
					return None
			elif isolated_bool(commands[3], 010):	#CAL:MON:VOLT:ISOL?
				if parameter_count == 0:
					return read_calibration_monitor_voltage_isolated(ch, channel_count)
				else:
					return None
		elif current_bool(commands[2], 001):
			if isolated_bool(commands[3], 001):	#CAL:MON:CURR:ISOL
				if parameter_count == 1:
					return write_calibration_monitor_current_isolated(parameters[0], ch)
				if parameter_count == 0:
					return write_calibration_monitor_current_isolated_interactive(ch)
				else:
					return None
			elif isolated_bool(commands[3], 010):	#CAL:MON:CURR:ISOL?
				if parameter_count == 0:
					return read_calibration_monitor_current_isolated(ch, channel_count)
				else:
					return None

	err_syntax_error(ch)
	return None



####################################################################################################
# Initiate subsystem fcns
####################################################################################################

#Fcn for initiate subsystem
def cmd_Initiate():
	print("Entered initiate subsystem")

	data1 = COMMAND_RECEIVED.upper().split(":")
	print("data1:", data1)

	if data1[0] == "":
		data1 = data1[1:]

	command_count = 0	#check the number of elements in data (number of "commands")
	for elements in data1:
		command_count += 1

	data2 = data1[command_count-1].split(" ")	#Split last element in data in case a parameter was given
	print("data2:", data2)
	data1 = data1[:(command_count-1)]	#Erase last element from data1
	print("new data1:", data1)
	commands = data1 + data2[:1]	#... and replace it with the first element of data 2. This way we omitt all parameters.
	parameters = data2[1:]	#Save the parameters in another variable
	print("commands:", commands)
	
	parameter_count = 0	#Count number of given parameters
	for elements in parameters:
		parameter_count += 1
		
	if parameter_count == 1:
		parameters = parameters[0].split(",")	#Parameters can also be separated by commas
		
		parameter_count = 0	#Count number of given parameters again
		for elements in parameters:
			parameter_count += 1
	
	print("parameters:", parameters)

	#Read which channel we look at:
	data3 = [commands[0].split("E"), commands[0].split("T")]
	print("data3:", data3)
	command = [data3[0][0] + "E", data3[1][0] + "T"]
	print("first command list:", command)


	for i in xrange(0, 2):
		if initiate_bool(command[i], 001):
			channel = data3[i][-1].split(",")
			print("channel:", channel)

			channel_count = 0	#check the number of elements in channel
			for elements in channel:
				channel_count += 1

			counter = 0
			ch = [0] * channel_count
			for elements in channel:
				if is_number(elements):
					if float(elements).is_integer():
						if 1 <= int(elements) <= 30:
							ch[counter] = int(elements) - 1	#Index of the parameters
							commands[0] = command[i]
						elif int(elements) == 0 and channel_count == 1:
							ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
							commands[0] = command[i]
						else:
							err_syntax_error(ch)
							return None
					else:
						err_syntax_error(ch)
						return None
				elif (elements == "" or elements == TERMINATOR) and channel_count == 1:
					ch[counter] = address	#Set index to default channel
					commands[0] = command[i]
				elif elements == "ALL" and channel_count == 1:
					ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
					commands[0] = command[i]
				else:
					err_syntax_error(ch)
					return None

				counter += 1
			break

	print("The channel index is:", ch)
	print("commands:", commands)

	if initiate_bool(commands[0], 001):	#INIT
		if command_count == 1:
			if parameter_count == 0:
				return initiate_autosequence(ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
		elif immediate_bool(commands[1], 001):	#INIT:IMM
			if command_count == 2:
				if parameter_count == 0:
					return initiate_autosequence(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None

	err_syntax_error(ch)
	return None



####################################################################################################
# Sense subsystem fcns
####################################################################################################

#Fcn for sense subsystem
def cmd_Sense():
	print("Entered sense subsystem")

	data1 = COMMAND_RECEIVED.upper().split(":")
	print("data1:", data1)

	if data1[0] == "":
		data1 = data1[1:]

	command_count = 0	#check the number of elements in data (number of "commands")
	for elements in data1:
		command_count += 1

	data2 = data1[command_count-1].split(" ")	#Split last element in data in case a parameter was given
	print("data2:", data2)
	data1 = data1[:(command_count-1)]	#Erase last element from data1
	print("new data1:", data1)
	commands = data1 + data2[:1]	#... and replace it with the first element of data 2. This way we omitt all parameters.
	parameters = data2[1:]	#Save the parameters in another variable
	print("commands:", commands)
	
	parameter_count = 0	#Count number of given parameters
	for elements in parameters:
		parameter_count += 1
		
	if parameter_count == 1:
		parameters = parameters[0].split(",")	#Parameters can also be separated by commas
		
		parameter_count = 0	#Count number of given parameters again
		for elements in parameters:
			parameter_count += 1
	
	print("parameters:", parameters)

	char_count = 0	#Count characters in commands[0]
	for char in commands[0]:
		char_count += 1

	#Read which channel we look at:
	if char_count > 4:
		if commands[0][4] == "E":
			data3 = commands[0].split("E")
			print("data3:", data3)
			command = data3[0] + "E" + data3[1] + "E"
			print("first command list:", command)
		else:
			data3 = commands[0].split("S")
			print("data3:", data3)
			command = "S" + data3[1] + "S"
			print("first command list:", command)
	else:
		data3 = commands[0].split("S")
		print("data3:", data3)
		command = "S" + data3[1] + "S"
		print("first command list:", command)

	if sense_bool(command, 001):
		channel = data3[-1].split(",")
		print("channel:", channel)

		channel_count = 0	#check the number of elements in channel
		for elements in channel:
			channel_count += 1

		counter = 0
		ch = [0] * channel_count
		for elements in channel:
			if is_number(elements):
				if float(elements).is_integer():
					if 1 <= int(elements) <= 30:
						ch[counter] = int(elements) - 1	#Index of the parameters
						commands[0] = command
					elif int(elements) == 0 and channel_count == 1:
						ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
						commands[0] = command
					else:
						err_syntax_error("ALL")
						return None
				else:
					err_syntax_error("ALL")
					return None
			elif elements == "" and channel_count == 1:
				ch[counter] = address	#Set index to default channel
				commands[0] = command
			elif elements == "ALL" and channel_count == 1:
				ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
				commands[0] = command
			else:
				err_syntax_error("ALL")
				return None

			counter += 1
	else:
		err_syntax_error("ALL")
		return None

	print("The channel index is:", ch)
	print("commands:", commands)

	if protection_bool(commands[1], 001):
		if interlock_bool(commands[2], 001):
			if command_count == 3:	#SENS:PROT:INT
				if parameter_count == 1:
					return write_sense_protection(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
			elif state_bool(commands[3], 001):	#SENS:PROT:STAT
				if command_count == 4:
					if parameter_count == 1:
						return write_sense_protection(parameters[0], ch)
					else:
						err_wrong_number_of_parameters(parameter_count, 1, ch)
						return None
			elif state_bool(commands[3], 010):	#SENS:PROT:INT:STAT?
				if command_count == 4:
					if parameter_count == 0:
						return read_sense_protection(ch, channel_count)
					else:
						err_wrong_number_of_parameters(parameter_count, 0, ch)
						return None
		elif interlock_bool(commands[2], 010):	#SENS:PROT:INT?
			if command_count == 3:
				if parameter_count == 0:
					return read_sense_protection(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None

	err_syntax_error(ch)
	return None



####################################################################################################
# Program subsystem fcns
####################################################################################################

#Fcn for program subsystem
def cmd_Program():
	print("Entered program subsystem")

	data1 = COMMAND_RECEIVED.upper().split(":")
	print("data1:", data1)

	if data1[0] == "":
		data1 = data1[1:]

	command_count = 0	#check the number of elements in data (number of "commands")
	for elements in data1:
		command_count += 1

	data2 = data1[command_count-1].split(" ")	#Split last element in data in case a parameter was given
	print("data2:", data2)
	data1 = data1[:(command_count-1)]	#Erase last element from data1
	print("new data1:", data1)
	commands = data1 + data2[:1]	#... and replace it with the first element of data 2. This way we omitt all parameters.
	parameters = data2[1:]	#Save the parameters in another variable
	print("commands:", commands)
	
	parameter_count = 0	#Count number of given parameters
	for elements in parameters:
		parameter_count += 1
		
	if parameter_count == 1:
		parameters = parameters[0].split(",")	#Parameters can also be separated by commas
		
		parameter_count = 0	#Count number of given parameters again
		for elements in parameters:
			parameter_count += 1
	
	print("parameters:", parameters)

	#Read which channel we look at:
	data3 = [commands[0].split("M"), commands[0].split("G")]
	print("data3:", data3)
	command = [data3[0][0] + "M", data3[1][0] + "G"]
	print("first command list:", command)

	for i in xrange(0, 2):
		if program_bool(command[i], 001):
			channel = data3[i][1].split(",")
			print("channel:", channel)

			channel_count = 0	#check the number of elements in channel
			for elements in channel:
				channel_count += 1

			counter = 0
			ch = [0] * channel_count
			for elements in channel:
				if is_number(elements):
					if float(elements).is_integer():
						if 1 <= int(elements) <= 30:
							ch[counter] = int(elements) - 1	#Index of the parameters
							commands[0] = command[i]
						elif int(elements) == 0 and channel_count == 1:
							ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
							commands[0] = command[i]
						else:
							err_syntax_error("ALL")
							return None
					else:
						err_syntax_error("ALL")
						return None
				elif elements == "" and channel_count == 1:
					ch[counter] = address	#Set index to default channel
					commands[0] = command[i]
				elif elements == "ALL" and channel_count == 1:
					ch = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]	#Set index to all values
					commands[0] = command[i]
				else:
					err_syntax_error("ALL")
					return None

				counter += 1
			break

	print("The channel index is:", ch)
	print("commands:", commands)

	if delete_bool(commands[1], 001):
		if all_bool(commands[2], 001):
			if command_count == 3:	#PROG:DEL:ALL
				if parameter_count == 0:
					return program_delete(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif state_bool(commands[1], 001):	#PROG:STAT
		if command_count == 2:
			if parameter_count == 1:
				return write_program_state(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif state_bool(commands[1], 010):	#PROG:STAT?
		if command_count == 2:
			if parameter_count == 0:
				return read_program_state(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif repeat_bool(commands[1], 001):	#PROG:REP
		if command_count == 2:
			if parameter_count == 1:
				return write_program_repeat(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif repeat_bool(commands[1], 010):	#PROG:REP?
		if command_count == 2:
			if parameter_count == 0:
				return read_program_repeat(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif start_bool(commands[1], 001):	#PROG:STAR
		if command_count == 2:
			if parameter_count == 0:
				return program_record_start(ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif stop_bool(commands[1], 001):	#PROG:STOP
		if command_count == 2:
			if parameter_count == 0:
				return program_record_stop(ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif record_bool(commands[1], 001):
		if start_bool(commands[2], 001):	#PROG:REC:STAR
			if command_count == 3:
				if parameter_count == 0:
					return program_record_start(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
		elif stop_bool(commands[2], 001):	#PROG:REC:STOP
			if command_count == 3:
				if parameter_count == 0:
					return program_record_stop(ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif dwel1_bool(commands[1], 001):	#PROG:DWEL1
		if command_count == 2:
			if parameter_count == 1:
				return write_program_step_dwel(parameters[0], ch)
			else:
				err_wrong_number_of_parameters(parameter_count, 1, ch)
				return None
	elif dwel1_bool(commands[1], 010):	#PROG:DWEL1?
		if command_count == 2:
			if parameter_count == 0:
				return read_program_step_dwel(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None
	elif step_bool(commands[1], 001):
		if dwel1_bool(commands[2], 001):	#PROG:STEP:DWEL1
			if command_count == 3:
				if parameter_count == 1:
					return write_program_step_dwel(parameters[0], ch)
				else:
					err_wrong_number_of_parameters(parameter_count, 1, ch)
					return None
		elif dwell_bool(commands[2], 010):	#PROG:STER:DWEL1?
			if command_count == 3:
				if parameter_count == 0:
					return read_program_step_dwel(ch, channel_count)
				else:
					err_wrong_number_of_parameters(parameter_count, 0, ch)
					return None
	elif readback_bool(commands[1], 010):	#PROG:READ?
		if command_count == 2:
			if parameter_count == 0:
				return read_program_readback(ch, channel_count)
			else:
				err_wrong_number_of_parameters(parameter_count, 0, ch)
				return None

	err_syntax_error(ch)
	return None




####################################################################################################
# Fcns used in write or read fcns below
####################################################################################################

#Fcn for writing output current or voltage
def write_output_value(value, maximum, i):
	print("Entered write output value")

	if value > maximum:
		err_data_out_of_range([i])	#write error message
		return False
	else:
		return value, True	#Change to new value

#Reset trigger flags
def reset_ramp_flags():
	global current_ramp_trig_flag, current_ramp_htrig_flag, voltage_ramp_trig_flag, voltage_ramp_htrig_flag

	current_ramp_trig_flag = current_ramp_htrig_flag = voltage_ramp_trig_flag = voltage_ramp_htrig_flag = 0

#Check if output voltage exceeds overvoltage protection
def overvoltage_protection(voltage, i):
	global output_voltage, output_current, tripped_over_flag

	tripped_over_flag[i] = 0	#ASSUMPTION: Reset it in case it was tripped but now we change to accepted value
						#Did not find anything in manuall about how you reset machine after overvoltage
						#had been tripped. So assume at the moment that you do not have too.

	if voltage > overvoltage[i]:
		output_voltage[i] = 0
		output_current[i] = 0
		tripped_over_flag[i] = 1
		set_operation_shutdown_protection_event_register(i)
		set_questionable_voltage_register(i)

#Check if output voltage is below undervoltage protection
def undervoltage_protection(voltage, i):
	global output_voltage, output_current, tripped_over_flag

	tripped_under_flag[i] = 0	#ASSUMPTION: Reset it in case it was tripped but now we change to accepted value
							#Did not find anything in manuall about how you reset machine after overvoltage
							#had been tripped. So assume at the moment that you do not have too.

	if voltage < undervoltage[i] and voltage != 0:
		output_voltage[i] = 0
		output_current[i] = 0
		tripped_under_flag[i] = 1
		set_operation_shutdown_protection_event_register(i)
		set_questionable_voltage_register(i)

#Functions_for_writing_or_reading_variables_________________________________________________________

#Current share controller:
def write_current_share(par, ch):	#No idea what effect this has
	global current_share

	print("I am here")

	for i in ch:
		if par == "CONT" + TERMINATOR or par == "CONTROLLER" + TERMINATOR:
			current_share[i] = "CONT"
			set_operation_cshare_register(i)
		elif par == "SLAV" + TERMINATOR or par == "SLAVE" + TERMINATOR:
			current_share[i] = "SLAV"
			set_operation_cshare_register(i)
		else:
			err_syntax_error(ch)
			return None

def read_current_share(ch, channel_count):

	print("Now I am here")

	if channel_count == 1:
		return current_share[ch[0]]
	else:
		for i in ch:
			if i == address:
				return current_share[address]

#Output current:
def write_output_current(par, ch):
	global output_current

	for i in ch:	#If all good change the values
		if is_number(par):	#Check if value is a number
			value = float(par)
		elif maximum_bool(par, 001):	#Check if parameter is "maximum"
			value = maximum_current[i]
		elif minimum_bool(par, 001):	#Check if parameter is "minimum"
			value = minimum_current[i]
		else:	#Else syntax error and break function
			err_syntax_error(ch)
			return None

		if write_output_value(value, maximum_current[i], i):	#Change value if these conditions are met
			output_current[i], dummy_variable = write_output_value(value, maximum_current[i], i)


def read_output_current(par, par_count, ch, channel_count):
	if channel_count == 1:
		if par_count == 0:
			return output_current[ch[0]]
		elif par_count == 1:
			if maximum_bool(par[0], 001):
				return maximum_current[ch[0]]
			elif minimum_bool(par[0], 001):
				return minimum_current[ch[0]]
		err_wrong_number_of_parameters(par_count, 1, ch)
		return None
	else:
		for i in ch:
			if i == address:
				if par_count == 0:
					return output_current[address]
				elif par_count == 1:
					if maximum_bool(par[0], 001):
						return maximum_current[address]
					elif minimum_bool(par[0], 001):
						return minimum_current[address]
				err_wrong_number_of_parameters(par_count, 1, ch)
				return None

#Constant power set point:
def write_power_set_point(par):
	global constant_power_set_point

	if is_number(par):
		constant_power_set_point = float(par)
	else:
		err_syntax_error("ALL")
		return None

def read_power_set_point():
	return constant_power_set_point

#Constant power mode:
def write_constant_power_mode(par):
	global constant_power_mode

	if is_number(par):
		if float(par) == 0 or float(par) == 1:
			constant_power_mode = int(par)
	elif par == "OFF" + TERMINATOR:
		constant_power_mode = 0
	elif par == "ON" + TERMINATOR:
		constant_power_mode = 1
	else:
		err_syntax_error("ALL")
		return None

def read_constant_power_mode():
	return constant_power_mode

#Output voltage:
def write_output_voltage(par, ch):
	global output_voltage

	for i in ch:	#If all good change the values
		if is_number(par):	#Check if value is a number
			value = float(par)
		elif maximum_bool(par, 001):	#Check if parameter is "maximum"
			value = maximum_voltage[i]
		elif minimum_bool(par, 001):	#Check if parameter is "minimum"
			value = minimum_voltage[i]
		else:	#Else syntax error and break function
			err_syntax_error(ch)
			return None

		if write_output_value(value, maximum_voltage[i], i):	#Change value if these conditions are met
			output_voltage[i], dummy_variable = write_output_value(value, maximum_voltage[i], i)
			overvoltage_protection(output_voltage[i], i)
			undervoltage_protection(output_voltage[i], i)


def read_output_voltage(par, par_count, ch, channel_count):
	if channel_count == 1:
		return output_voltage[ch[0]]
	else:
		for i in ch:
			if i == address:
				return output_voltage[address]

	if channel_count == 1:
		if par_count == 0:
			return output_voltage[ch[0]]
		elif par_count == 1:
			if maximum_bool(par[0], 001):
				return maximum_voltage[ch[0]]
			elif minimum_bool(par[0], 001):
				return minimum_voltage[ch[0]]

		err_wrong_number_of_parameters(par_count, 1, ch)
		return None
	else:
		for i in ch:
			if i == address:
				if par_count == 0:
					return output_voltage[address]
				elif par_count == 1:
					if maximum_bool(par[0], 001):
						return maximum_voltage[address]
					elif minimum_bool(par[0], 001):
						return minimum_voltage[address]

				err_wrong_number_of_parameters(par_count, 1, ch)
				return None


#Voltage protection (overvoltage):
def write_overvoltage(par, ch):
	global overvoltage

	if is_number(par):	#Check if the parameter is correct
		for i in ch:
			overvoltage[i] = float(par)
			overvoltage_protection(output_voltage[i], i)	#Check if overvoltage is smaller than output voltage
	elif maximum_bool(par):
		for i in ch:
			overvoltage[i] = maximum_voltage[i]
			overvoltage_protection(output_voltage[i], i)	#Check if overvoltage is smaller than output voltage
	elif minimum_bool(par):
		for i in ch:
			overvoltage[i] = minimum_voltage[i]
			overvoltage_protection(output_voltage[i], i)	#Check if overvoltage is smaller than output voltage
	else:
		err_syntax_error(ch)
		return None


def read_overvoltage(ch, channel_count):
	if channel_count == 1:
		return overvoltage[ch[0]]
	else:
		for i in ch:
			if i == address:
				return overvoltage[address]


#Voltage protection (undervoltage):
def write_undervoltage(par, ch):
	global undervoltage

	if is_number(par):	#Check if the parameter is correct
		for i in ch:
			undervoltage[i] = float(par)
			undervoltage_protection(output_voltage[i], i)	#Check if undervoltage is larger than output voltage
	elif maximum_bool(par):
		for i in ch:
			undervoltage[i] = maximum_voltage[i]
			undervoltage_protection(output_voltage[i], i)	#Check if undervoltage is large than output voltage
	elif minimum_bool(par):
		for i in ch:
			undervoltage[i] = minimum_voltage[i]
			undervoltage_protection(output_voltage[i], i)	#Check if undervoltage is larger than output voltage
	else:
		err_syntax_error(ch)
		return None


def read_undervoltage(ch, channel_count):
	if channel_count == 1:
		return undervoltage[ch[0]]
	else:
		for i in ch:
			if i == address:
				return undervoltage[address]

#Measure aprogram current
def measure_aprogram_current():	#I do not know it should return
	return 15

def measure_aprogram_current_isolated():	#I do not know it should return
	return 20

#Measure aprogram voltage
def measure_aprogram_voltage():	#I do not know it should return
	return 10

def measure_aprogram_voltage_isolated():	#I do not know it should return
	return 12

#Measure current
def measure_current(ch, channel_count):
	global meas_current

	meas_current = output_current	#Just return same as output

	if channel_count == 1:
		return meas_current[ch[0]]
	else:
		for i in ch:
			if i == address:
				return meas_current[address]

#Measure Voltage
def measure_voltage(ch, channel_count):
	global meas_voltage

	meas_voltage = output_voltage	#Just return same as output

	if channel_count == 1:
		return meas_voltage[ch[0]]
	else:
		for i in ch:
			if i == address:
				return meas_voltage[address]


#Output polarity
def write_output_polarity(par, ch):	#I don't know what this funciton does or what parameter it can take
	global output_polarity

	if par == "HIGH" + TERMINATOR:
		for i in ch:
			output_polarity[i] = "HIGH"
		return None
	elif par == "LOW" + TERMINATOR:
		for i in ch:
			output_polarity[i] = "LOW"
		return None

	err_syntax_error(ch)
	return None

def read_output_polarity(ch, channel_count):
	if channel_count == 1:
		return output_polarity[ch[0]]
	else:
		for i in ch:
			if i == address:
				return output_polarity[address]

#Protection clear
def output_protection_clear(ch):
	global overvoltage, undervoltage

	for i in ch:
		overvoltage[i] = 1.1 * maximum_voltage[i]
		undervoltage[i] = 0

#Output protection foldback delay
def write_output_protection_foldback_delay(par, ch):
	global foldback_delay

	if is_number(par):	#Check if value is a number
		if 0.5 < float(par) < 50:
			for i in ch:	#If all good change the values
				foldback_delay[i] = float(par)
			return None
		else:
			err_data_out_of_range(ch)
			return None

	err_syntax_error(ch)
	return None

def read_output_protection_foldback_delay(ch, channel_count):
	if channel_count == 1:
		return foldback_delay[ch[0]]
	else:
		for i in ch:
			if i == address:
				return foldback_delay[address]

#Output protection foldback mode
def write_output_protection_foldback_mode(par, ch):
	global foldback_mode

	if par == "CV" + TERMINATOR:
		for i in ch:	#If all good change the values
			foldback_mode[i] = "CV"
		return None
	elif par == "CC" + TERMINATOR:
		for i in ch:	#If all good change the values
			foldback_mode[i] = "CC"
		return None
	elif par == "NONE" + TERMINATOR:
		for i in ch:	#If all good change the values
			foldback_mode[i] = "NONE"
		return None

	err_syntax_error(ch)
	return None

def read_output_protection_foldback_mode(ch, channel_count):
	if channel_count == 1:
		return foldback_mode[ch[0]]
	else:
		for i in ch:
			if i == address:
				return foldback_mode[address]

#Output power state
def write_output_power_state(par, ch):	#I assume this turns on and off the output, but not implemented
	global output_power_state

	if is_number(par):
		if float(par) == 0 or float(par) == 1:
			for i in ch:
				output_power_state[i] = int(par)
			return None
	elif par == "ON" + TERMINATOR:
		for i in ch:
			output_power_state[i] = 1
		return None
	elif par == "OFF" + TERMINATOR:
		for i in ch:
			output_power_state[i] = 0
		return None

	err_syntax_error(ch)
	return None

def read_output_power_state(ch, channel_count):
	if channel_count == 1:
		return output_power_state[ch[0]]
	else:
		for i in ch:
			if i == address:
				return output_power_state[address]

#Output power pon state
def write_output_power_pon_state(par, ch):	#Don't know what triggers autostart, so not implemented
	global output_autostart

	if is_number(par):
		if float(par) == 0 or float(par) == 1:
			for i in ch:
				output_autostart[i] = int(par)
			return None
	elif par == "ON" + TERMINATOR:
		for i in ch:	#If all good change the values
			output_autostart[i] = 1
		return None
	elif par == "OFF" + TERMINATOR:
		for i in ch:	#If all good change the values
			output_autostart[i] = 0
		return None

	err_syntax_error(ch)
	return None

def read_output_power_pon_state(ch, channel_count):
	if channel_count == 1:
		return output_autostart[ch[0]]
	else:
		for i in ch:
			if i == address:
				return output_autostart[address]

#Output auxilliary state
def write_output_auxilliary_state(par, ch):	#Don't know what triggers autostart, so not implemented
	global output_auxilliary_state

	if is_number(par):
		if float(par) == 0 or float(par) == 1:
			for i in ch:
				output_auxilliary_state[i] = int(par)
			return None
	elif par == "ON" + TERMINATOR:
		for i in ch:	#If all good change the values
			output_auxilliary_state[i] = 1
		return None
	elif par == "OFF" + TERMINATOR:
		for i in ch:	#If all good change the values
			output_auxilliary_state[i] = 0
		return None

	err_syntax_error(ch)
	return None

def read_output_auxilliary_state(ch, channel_count):
	if channel_count == 1:
		return output_auxilliary_state[ch[0]]
	else:
		for i in ch:
			if i == address:
				return output_auxilliary_state[address]

#Output auxilliary pon state
def write_output_auxilliary_pon_state(par, ch):	#Don't know what triggers autostart, so not implemented
	global output_auxilliary_autostart

	if is_number(par):
		if float(par) == 0 or float(par) == 1:
			for i in ch:
				output_auxilliary_autostart[i] = int(par)
			return None
	elif par == "ON" + TERMINATOR:
		for i in ch:	#If all good change the values
			output_auxilliary_autostart[i] = 1
		return None
	elif par == "OFF" + TERMINATOR:
		for i in ch:	#If all good change the values
			output_auxilliary_autostart[i] = 0
		return None

	err_syntax_error(ch)
	return None

def read_output_auxilliary_pon_state(ch, channel_count):
	if channel_count == 1:
		return output_auxilliary_autostart[ch[0]]
	else:
		for i in ch:
			if i == address:
				return output_auxilliary_autostart[address]
				
				
#System fpanel timeout
def write_system_fpanel_timeout(par, ch):
	global fpanel_timeout
	
	if is_number(par):
		if 1<= float(par) <= 20:	#to one decimal place
			for i in ch:
				fpanel_timeout[i] = float(par)
			return None
		else:
			err_data_out_of_range(ch)
			return None
	
	err_syntax_error(ch)
	return None
	
def read_system_fpanel_timeout(ch, channel_count):
	if channel_count == 1:
		return fpanel_timeout[ch[0]]
	else:
		for i in ch:
			if i == address:
				return fpanel_timeout[address]
				
#System reset
def system_reset(ch):
	'''
	Supposed to reset all values except calibration data
	'''
	status_clear(ch, "Not needed")
	
	return None

#System wait
def system_wait(ch):
	#Assume it means to wait with commands untill all pending commands are done
	global wait_flag

	wait_flag = 1	#Not implemented yet
	
#System test
def read_system_test(ch, channel_count):
	'''
	Internal test. Status 0 means all is good
	'''
	return 0
	
#System id string
def read_system_id(ch, channel_count):
	'''
	returns id string.
	'''
	#Not sure how it looks exactly. The example most likely does not have the correct format.
	
	return "Sorensen, XG 850-1.4, SN# 1104A00207"
	
#System save and recall
def system_save(par, ch):
	'''
	Supposed to save the user preset values in slot 0 to 3. 
	'''
	#Not implemented
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 3:
				#Save values
				return None
			else:
				err_data_out_of_range(ch)
				return None
	return None
	
def system_recall(par, ch):
	'''
	Read saved values, location index 0-3
	'''
	#Not implemented
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 3:
				#Read saved values
				return None
			else:
				err_data_out_of_range(ch)
				return None
	return None
	
#System error
def read_system_error(ch, channel_count):
	global ERR

	if channel_count == 1:
		error = ERR[ch[0]][0]	#Retrieve first element in error queue
		description = err_description(error)

		ERR[ch[0]] = ERR[ch[0]][1:] + [0]	#Shift elements in queue one step to the left
		print("Error queue after shift:", ERR[ch[0]])

		return str(error) + description
	else:
		for i in ch:
			if i == address:
				error = ERR[address][0]	#Retrieve first element in error queue
				description = err_description(error)

				ERR[address] = ERR[address][1:] + [0]	#Shift elements in queue one step to the left
				print("Error queue after shift:", ERR[address])

				return str(error) + description
	
def read_system_error_code(ch, channel_count):
	global ERR
	
	if channel_count == 1:
		error = ERR[ch[0]][0]	#Retrieve first element in error queue

		ERR[ch[0]] = ERR[ch[0]][1:] + [0]	#Shift elements in queue one step to the left
		print("Error queue after shift:", ERR[ch[0]])

		return error
	else:
		for i in ch:
			if i == address:
				error = ERR[address][0]	#Retrieve first element in error queue

				ERR[address] = ERR[address][1:] + [0]	#Shift elements in queue one step to the left
				print("Error queue after shift:", ERR[address])

				return error

def read_system_error_count(ch, channel_count):
	
	if channel_count == 1:
		error_count = 0
		for error in ERR[ch[0]]:
			if error != 0:
				error_count += 1

		return error_count
	else:
		for i in ch:
			if i == address:
				error_count = 0
				for error in ERR[address]:
					if error != 0:
						error_count += 1

				return error_count
				
#System communicate aprogram level voltage
def write_system_apg_voltage(par, ch):
	'''
	Select level for Voltage APG (don't know what it is)
	'''
	global apg_voltage
	
	if is_number(par):
		if 1<= float(par) <= 10:
			for i in ch:
				apg_voltage[i] = float(par)
			return None
		else:
			err_data_out_of_range(ch)
			return None
	elif maximum_bool(par, 001):
		for i in ch:
			apg_voltage[i] = 10.0
		return None
	elif minimum_bool(par, 001):
		for i in ch:
			apg_voltage[i] = 2.0
		return None
	
	err_syntax_error(ch)
	return None
	
def read_system_apg_voltage(ch, channel_count):
	if channel_count == 1:
		return apg_voltage[ch[0]]
	else:
		for i in ch:
			if i == address:
				return apg_voltage[address]

#System communicate aprogram level current
def write_system_apg_current(par, ch):
	'''
	Select level for Current APG (don't know what it is)
	'''
	global apg_current
	
	if is_number(par):
		if 1<= float(par) <= 10:
			for i in ch:
				apg_current[i] = float(par)
			return None
		else:
			err_data_out_of_range(ch)
			return None
	elif maximum_bool(par, 001):
		for i in ch:
			apg_current[i] = 10.0
		return None
	elif minimum_bool(par, 001):
		for i in ch:
			apg_current[i] = 2.0
		return None
	
	err_syntax_error(ch)
	return None

def read_system_apg_current(ch, channel_count):
	if channel_count == 1:
		return apg_current[ch[0]]
	else:
		for i in ch:
			if i == address:
				return apg_current[address]

#System communicate mchannel address
def write_system_address(par, ch):
	'''
	Select device to receive the commands. Address is set on the front panel under the remote
	'''
	#No idea about the syntax of the address
	global system_address
	
	for i in ch:
		system_address[i] = par[:-2]
	return None
	
	err_syntax_error(ch)
	return None

def read_system_address(ch, channel_count):
	if channel_count == 1:
		return system_address[ch[0]]
	else:
		for i in ch:
			if i == address:
				return system_address[address]

#System remote source voltage
def write_system_remote_voltage(par, ch):
	'''
	Alter the state of remote programming voltage APG source
	'''
	global apg_voltage_state
	
	if local_bool(par, 001):
		for i in ch:
			apg_voltage_state[i] = "LOC"
		return None
	elif avoltage_bool(par, 001):
		for i in ch:
			apg_voltage_state[i] = "AVOL"
		return None
	elif iavoltage_bool(par, 001):
		for i in ch:
			apg_voltage_state[i] = "IAV"
		return None
	elif aresistive_bool(par, 001):
		for i in ch:
			apg_voltage_state[i] = "ARES"
		return None
	elif iaresistive_bool(par, 001):
		for i in ch:
			apg_voltage_state[i] = "IAR"
		return None
	
	err_syntax_error(ch)
	return None

def read_system_remote_voltage(ch, channel_count):
	if channel_count == 1:
		return apg_voltage_state[ch[0]]
	else:
		for i in ch:
			if i == address:
				return apg_voltage_state[address]
				
#System remote source current
def write_system_remote_current(par, ch):
	'''
	Alter the state of remote programming current APG source
	'''
	global apg_current_state
	
	if local_bool(par, 001):
		for i in ch:
			apg_current_state[i] = "LOC"
		return None
	elif avoltage_bool(par, 001):
		for i in ch:
			apg_current_state[i] = "AVOL"
		return None
	elif iavoltage_bool(par, 001):
		for i in ch:
			apg_current_state[i] = "IAV"
		return None
	elif aresistive_bool(par, 001):
		for i in ch:
			apg_current_state[i] = "ARES"
		return None
	elif iaresistive_bool(par, 001):
		for i in ch:
			apg_current_state[i] = "IAR"
		return None
	
	err_syntax_error(ch)
	return None

def read_system_remote_current(ch, channel_count):
	if channel_count == 1:
		return apg_current_state[ch[0]]
	else:
		for i in ch:
			if i == address:
				return apg_current_state[address]

#System remote state
def write_system_remote_state(par, ch):
	'''
	Change front panel control mode
	'''
	global remote_state
	
	if local_bool(par, 001):
		for i in ch:
			remote_state[i] = "LOC"
		return None
	elif remote_bool(par, 001):
		for i in ch:
			remote_state[i] = "REM"
		return None
	
	err_syntax_error(ch)
	return None
	
def read_system_remote_state(ch, channel_count):
	if channel_count == 1:
		return remote_state[ch[0]]
	else:
		for i in ch:
			if i == address:
				return remote_state[address]

#System pon voltage
def write_system_pon_voltage(par, ch):
	'''
	Set the voltage set point to zero when the power is turned on (don't get it)
	'''
	global pon_voltage
	
	if is_number(par):
		if float(par) == 0 or float(par) == 1:
			for i in ch:
				pon_voltage[i] = int(par)
			return None
	elif par == "ON" + TERMINATOR:
		for i in ch:	#If all good change the values
			pon_voltage[i] = 1
		return None
	elif par == "OFF" + TERMINATOR:
		for i in ch:	#If all good change the values
			pon_voltage[i] = 0
		return None

	err_syntax_error(ch)
	return None
	
def read_system_pon_voltage(ch, channel_count):
	if channel_count == 1:
		return pon_voltage[ch[0]]
	else:
		for i in ch:
			if i == address:
				return pon_voltage[address]

#System pon current
def write_system_pon_current(par, ch):
	global pon_current
	
	if is_number(par):
		if float(par) == 0 or float(par) == 1:
			for i in ch:
				pon_current[i] = int(par)
			return None
	elif par == "ON" + TERMINATOR:
		for i in ch:	#If all good change the values
			pon_current[i] = 1
		return None
	elif par == "OFF" + TERMINATOR:
		for i in ch:	#If all good change the values
			pon_current[i] = 0
		return None

	err_syntax_error(ch)
	return None

def read_system_pon_current(ch, channel_count):
	if channel_count == 1:
		return pon_current[ch[0]]
	else:
		for i in ch:
			if i == address:
				return pon_current[address]

#System pon enable voltage
def write_system_pon_enable_voltage(par, ch):
	'''
	Set the voltage set point to zero when the output enable button is pressed (don't get it)
	'''
	global pon_enable_voltage
	
	if is_number(par):
		if float(par) == 0 or float(par) == 1:
			for i in ch:
				pon_enable_voltage[i] = int(par)
			return None
	elif par == "ON" + TERMINATOR:
		for i in ch:	#If all good change the values
			pon_enable_voltage[i] = 1
		return None
	elif par == "OFF" + TERMINATOR:
		for i in ch:	#If all good change the values
			pon_enable_voltage[i] = 0
		return None

	err_syntax_error(ch)
	return None
	
def read_system_pon_enable_voltage(ch, channel_count):
	if channel_count == 1:
		return pon_enable_voltage[ch[0]]
	else:
		for i in ch:
			if i == address:
				return pon_enable_voltage[address]

#System pon enable current
def write_system_pon_enable_current(par, ch):
	global pon_enable_current
	
	if is_number(par):
		if float(par) == 0 or float(par) == 1:
			for i in ch:
				pon_enable_current[i] = int(par)
			return None
	elif par == "ON" + TERMINATOR:
		for i in ch:	#If all good change the values
			pon_enable_current[i] = 1
		return None
	elif par == "OFF" + TERMINATOR:
		for i in ch:	#If all good change the values
			pon_enable_current[i] = 0
		return None

	err_syntax_error(ch)
	return None
	
def read_system_pon_enable_current(ch, channel_count):
	if channel_count == 1:
		return pon_enable_current[ch[0]]
	else:
		for i in ch:
			if i == address:
				return pon_enable_current[address]

#System version
def read_system_version(ch, channel_count):
	'''
	Returns the SCPI version to which the instrument complies.
	Format is YYYY.V	(Numbers or letters?)
	'''
	return 1111.5
	
#System help legacy
def read_system_help_legacy(ch, channel_count):
	#Return all supported legacy commands (what are the legacy commands?)
	
	return "String with supported legacy commands"
	
#System help header
def read_system_help_header(ch, channel_count):
	'''
	Return all supported SCPI command headers (Whole list of all commands as in manual)
	'''
	#Supposed to be full command list but that is a lot of work
	
	return "CALibration", "INITiate", "MEASure", "OUTPut", "PROGram", "SOURce", "SENSe", "STATus", "SYSTem"
	
#System protection mask
def write_system_protection_mask(par, ch):
	'''
	Enable/disabel alarms/protection
	'''
	global protection_enable_mask
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 2047:
				for i in ch:
					protection_enable_mask[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None
		
def read_system_protection_mask(ch, channel_count):
	if channel_count == 1:
		return protection_enable_mask[ch[0]]
	else:
		for i in ch:
			if i == address:
				return protection_enable_mask[address]
				
#System protection latch
def write_system_protection_latch(par, ch):
	'''
	Sets the Alarm Output Latches. See Table 3-6 on page 3-24 (page 70 in pdf)
	'''
	global system_protection_latch
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 7 or 256 <= int(par) <= 263:
				for i in ch:
					system_protection_latch[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None
	
def read_system_protection_latch(ch, channel_count):
	if channel_count == 1:
		return system_protection_latch[ch[0]]
	else:
		for i in ch:
			if i == address:
				return system_protection_latch[address]


#Status operation condition
def read_status_operation_condition(ch, channel_count):
	'''
	Query the Operations Condition Register.
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-12 (p.172).
	
	I have not implemented anything activating register.
	Don't know what the difference is between all the registers referencing same table.
	'''
	if channel_count == 1:
		return operation_condition_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_condition_register[address]

#Status operation enable
def write_status_operation_enable(par, ch):
	'''
	Change Operations Enable Register. See table 5-11 page 5-36. OBS! I think it actually is table 5-12 (p.172)
	I believe it changes which bits can be activated in the operation event register,
	but this is just a guess.
	'''
	global operation_enable_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_enable_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None
	
def read_status_operation_enable(ch, channel_count):
	'''
	Query the Operations Enable Register.
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-12 (p.172)
	'''
	if channel_count == 1:
		return operation_enable_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_enable_register[address]

#Status operation event register
def read_status_operation_event(ch, channel_count):
	'''
	Query the Operations Event Register.
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-12 (p.172)
	'''
	if channel_count == 1:
		return operation_event_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_event_register[address]

#Status operation negative trans filter
def write_status_operation_ntransition(par, ch):
	'''
	Change Operation Negative Trans Filter Register. See table 5-11 page 5-36. OBS! I think it actually is table 5-12 (p.172)
	No idea what it does.
	'''
	global operation_ntrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_ntrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_operation_ntransition(ch, channel_count):
	'''
	Query the Operation Negative Trans Filter Register.
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-12 (p.172)
	'''
	if channel_count == 1:
		return operation_ntrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_ntrans_register[address]

#Status operation positive trans filter			
def write_status_operation_ptransition(par, ch):
	'''
	Change Operation Positive Trans Filter Register. See table 5-11 page 5-36. OBS! I think it actually is table 5-12 (p.172)
	No idea what it does.
	'''
	global operation_ptrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_ptrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None
	
def read_status_operation_ptransition(ch, channel_count):
	'''
	Query the Operation Positive Trans Filter Register.
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-12 (p.172)
	'''
	if channel_count == 1:
		return operation_ptrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_ntrans_register[address]

#Status operation shutdown condition
def read_status_operation_shutdown_condition(ch, channel_count):
	'''
	Query the Operation Shutdown Condition Register.
	See table 5-13 page 5-41 (page 168 in pdf).
	
	I have not implemented anything activating register.
	Don't know what the difference is between all the registers referencing same table.	
	'''
	if channel_count == 1:
		return operation_shutdown_condition_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_shutdown_condition_register[address]

#Status operation shutdown enable
def write_status_operation_shutdown_enable(par, ch):
	'''
	Change Operation Shutdown Enable Register. See table 5-13 page 5-41.
	I believe it changes which bits can be activated in the operation shutdown event register,
	but this is just a guess.
	'''
	global operation_shutdown_enable_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_shutdown_enable_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_operation_shutdown_enable(ch, channel_count):
	'''
	Query the Operation Shutdown Enable Register.
	See table 5-13 page 5-41 (page 168 in pdf).	
	'''
	if channel_count == 1:
		return operation_shutdown_enable_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_shutdown_enable_register[address]

#Status operation shutdown event
def read_status_operation_shutdown_event(ch, channel_count):
	'''
	Query the Operation Shutdown Event Register.
	See table 5-13 page 5-41 (page 168 in pdf).
	'''
	global operation_shutdown_event_register

	if channel_count == 1:
		return operation_shutdown_event_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_shutdown_event_register[address]

#Status operation shutdown negative trans filter
def write_status_operation_shutdown_ntranstion(par, ch):
	'''
	Change Operation Shutdown Negative Trans Filter Register. See table 5-13 page 5-41.
	'''
	global operation_shutdown_ntrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_shutdown_ntrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_operation_shutdown_ntransition(ch, channel_count):
	'''
	Query the Operation Shutdown Negative Trans Filter Register.
	See table 5-13 page 5-41 (page 168 in pdf).	
	'''
	if channel_count == 1:
		return operation_shutdown_ntrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_shutdown_ntrans_register[address]

#Status operation shutdown positive trans filter
def write_status_operation_shutdown_ptranstion(par, ch):
	'''
	Change Operation Shutdown Positive Trans Filter Register. See table 5-13 page 5-41.
	'''
	global operation_shutdown_ptrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_shutdown_ptrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None	

	err_syntax_error(ch)
	return None

def read_status_operation_shutdown_ptransition(ch, channel_count):
	'''
	Query the Operation Shutdown Positive Trans Filter Register.
	See table 5-13 page 5-41 (page 168 in pdf).	
	'''
	if channel_count == 1:
		return operation_shutdown_ptrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_shutdown_ntrans_register[address]

#Status operation shutdown protection condition
def read_status_operation_shutdown_protection_condition(ch, channel_count):
	'''
	Query the Operation Shutdown Protection Condition Register.
	See table 5-12 page 5-40 (page 168 in pdf). OBS! I think it actually is table 5-14 (p.172)
	
	I have not implemented anything activating register.
	Don't know what the difference is between all the registers referencing same table.	
	'''
	if channel_count == 1:
		return operation_shutdown_protection_condition_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_shutdown_protection_condition_register[address]
				
#Status operation shutdown protection enable
def write_status_operation_shutdown_protection_enable(par, ch):
	'''
	Change Operation Shutdown Protection Enable Register. 
	See table 5-12 page 5-40. OBS! I think it actually is table 5-14 (p.172)
	I believe it changes which bits can be activated in the operation shutdown protection event register,
	but this is just a guess.
	'''
	global operation_shutdown_protection_enable_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_shutdown_protection_enable_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None
	
def read_status_operation_shutdown_protection_enable(ch, channel_count):
	'''
	Query the Operation Shutdown Protection Enable Register.
	See table 5-13 page 5-40 (page 168 in pdf).	OBS! I think it actually is table 5-14 (p.172)
	'''
	if channel_count == 1:
		return operation_shutdown_protection_enable_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_shutdown_protection_enable_register[address]
				
#Status operation shutdown protection event
def read_status_operation_shutdown_protection_event(ch, channel_count):
	'''
	Query the Operation Shutdown Protection Event Register.
	See table 5-13 page 5-40 (page 168 in pdf).	OBS! I think it actually is table 5-14 (p.172)
	'''
	if channel_count == 1:
		return operation_shutdown_protection_event_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_shutdown_protection_event_register[address]

#Status operation shutdown protection negatice trans filter
def write_status_operation_shutdown_protection_ntranstion(par, ch):
	'''
	Change Operation Shutdown Protection Negative Trans Filter Register. 
	See table 5-12 page 5-40. OBS! I think it actually is table 5-14 (p.172)
	'''
	global operation_shutdown_protection_ntrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_shutdown_protection_ntrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None

				
	err_syntax_error(ch)
	return None
	
def read_status_operation_shutdown_protection_ntransition(ch, channel_count):
	'''
	Query the Operation Shutdown Protection Negative Trans Filter Register.
	See table 5-13 page 5-40 (page 168 in pdf).	OBS! I think it actually is table 5-14 (p.172)
	'''
	if channel_count == 1:
		return operation_shutdown_protection_ntrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_shutdown_protection_ntrans_register[address]
				
#Status operation shutdown positive trans filter
def write_status_operation_shutdown_protection_ptranstion(par, ch):
	'''
	Change Operation Shutdown Protection Positive Trans Filter Register. 
	See table 5-12 page 5-40. OBS! I think it actually is table 5-14 (p.172)
	'''
	global operation_shutdown_protection_ptrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_shutdown_protection_ptrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None
	
def read_status_operation_shutdown_protection_ptransition(ch, channel_count):
	'''
	Query the Operation Shutdown Protection Positive Trans Filter Register.
	See table 5-13 page 5-40 (page 168 in pdf).	OBS! I think it actually is table 5-14 (p.172)
	'''
	if channel_count == 1:
		return operation_shutdown_protection_ptrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_shutdown_protection_ptrans_register[address]

#Status operation cshare event
def read_status_operation_cshare_event(ch, channel_count):
	'''
	Query the Operations Cshare Event Register. (No Cshare in manual, but must be incorrect)
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-15 (p.174)
	'''
	if channel_count == 1:
		return operation_cshare_event_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_event_register[address]

#Status operation chsare enable				
def write_status_operation_cshare_enable(par, ch):
	'''
	Change Operation Cshare Enable Register. (No Cshare in manual, but must be incorrect)
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-15 (p.174)
	'''
	global operation_cshare_enable_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_cshare_enable_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_operation_cshare_enable(ch, channel_count):
	'''
	Query the Operations Cshare Enable Register. (No Cshare in manual, but must be incorrect)
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-15 (p.174)
	'''
	if channel_count == 1:
		return operation_cshare_enable_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_cshare_enable_register[address]

#Status operation cshare condition
def read_status_operation_cshare_condition(ch, channel_count):
	'''
	Query the Operations Cshare Condition Register. (No Cshare in manual, but must be incorrect)
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-15 (p.174)
	
	I have not implemented anything activating register.
	'''
	if channel_count == 1:
		return operation_cshare_condition_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_cshare_condition_register[address]

#Status operation cshare positive trans filter
def write_status_operation_cshare_ptransitions(par, ch):
	'''
	Change Operation Cshare Positive Trans Filter Register. (No Cshare in manual, but must be incorrect)
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-15 (p.174)
	'''
	global operation_cshare_ptrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_cshare_ptrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_operation_cshare_ptransition(ch, channel_count):
	'''
	Query the Operations Cshare Positive Trans Filter Register. (No Cshare in manual, but must be incorrect)
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-15 (p.174)
	'''
	if channel_count == 1:
		return operation_cshare_ptrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_cshare_ptrans_register[address]	
				
#Status operation cshare negative trans filter
def write_status_operation_cshare_ntransitions(par, ch):
	'''
	Change Operation Cshare Negative Trans Filter Register. (No Cshare in manual, but must be incorrect)
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-15 (p.174)
	'''
	global operation_cshare_ntrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					operation_cshare_ntrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_operation_cshare_ntransition(ch, channel_count):
	'''
	Query the Operations Cshare Negative Trans Filter Register. (No Cshare in manual, but must be incorrect)
	See table 5-11 page 5-36 (page 168 in pdf). OBS! I think it actually is table 5-15 (p.174)
	'''
	if channel_count == 1:
		return operation_cshare_ntrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return operation_cshare_ntrans_register[address]	

#Status preset
def status_preset(ch, channel_count):
	'''
	Restores the configuration of the SCPI status registers to known 
	reporting conditions, IE Transition registers and enable registers.
	See "Status Reporting in SCPI", p. 5-29 (161)
	'''
	
	return None
	
#Status questionable event
def read_status_questionable_event(ch, channel_count):
	'''
	Query the Questionable Event Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-16 (p.181)
	'''
	if channel_count == 1:
		return questionable_event_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_event_register[address]

#Status questionable enable
def write_status_questionable_enable(par, ch):
	'''
	Change Questionable Enable Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-16 (p.181)
	'''
	global questionable_enable_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					questionable_enable_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_questionable_enable(ch, channel_count):
	'''
	Query the Questionable Enable Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-16 (p.181)
	'''
	if channel_count == 1:
		return questionable_enable_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_enable_register[address]

#Status questionable condition
def read_status_questionable_condition(ch, channel_count):
	'''
	Query the Questionable Condition Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-16 (p.181)
	'''
	if channel_count == 1:
		return questionable_condition_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_condition_register[address]

#Status questionable negative trans filter
def write_status_questionable_ntransition(par, ch):
	'''
	Change Questionable Negative Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-16 (p.181)
	'''
	global questionable_ntrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					questionable_ntrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_questionable_ntransition(ch, channel_count):
	'''
	Query the Questionable Negative Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-16 (p.181)
	'''
	if channel_count == 1:
		return questionable_ntrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_ntrans_register[address]

#Status questionable positive trans filter
def write_status_questionable_ptransition(par, ch):
	'''
	Change Questionable Positibe Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-16 (p.181)
	'''
	global questionable_ptrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					questionable_ptrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_questionable_ptransition(ch, channel_count):
	'''
	Query the Questionable Positive Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-16 (p.181)
	'''
	if channel_count == 1:
		return questionable_ptrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_ptrans_register[address]

#Status questionable temperature event
def read_status_questionable_temperature_event(ch, channel_count):
	'''
	Query the Questionable Event Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-18 (p.182)
	'''
	if channel_count == 1:
		return questionable_temperature_event_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_temperature_event_register[address]

#Status questionable temperature enable
def write_status_questionable_temperature_enable(par, ch):
	'''
	Change Questionable Enable Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-18 (p.182)
	'''
	global questionable_temperature_enable_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					questionable_temperature_enable_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_questionable_temperature_enable(ch, channel_count):
	'''
	Query the Questionable Enable Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-18 (p.182)
	'''
	if channel_count == 1:
		return questionable_temperature_enable_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_temperature_enable_register[address]

#Status questionable temperature condition
def read_status_questionable_temperature_condition(ch, channel_count):
	'''
	Query the Questionable Condition Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-18 (p.182)
	'''
	if channel_count == 1:
		return questionable_temperature_condition_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_temperature_condition_register[address]

#Status questionable temperature negative trans filter
def write_status_questionable_temperature_ntransition(par, ch):
	'''
	Change Questionable Negative Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-18 (p.182)
	'''
	global questionable_temperature_ntrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					questionable_temperature_ntrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_questionable_temperature_ntransition(ch, channel_count):
	'''
	Query the Questionable Negative Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-18 (p.182)
	'''
	if channel_count == 1:
		return questionable_temperature_ntrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_temperature_ntrans_register[address]

#Status questionable temperature positive trans filter
def write_status_questionable_temperature_ptransition(par, ch):
	'''
	Change Questionable Positibe Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-18 (p.182)
	'''
	global questionable_temperature_ptrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					questionable_temperature_ptrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_questionable_temperature_ptransition(ch, channel_count):
	'''
	Query the Questionable Positive Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-18 (p.182)
	'''
	if channel_count == 1:
		return questionable_temperature_ptrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_temperature_ptrans_register[address]

#Status questionable voltage event
def read_status_questionable_voltage_event(ch, channel_count):
	'''
	Query the Questionable Event Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-17 (p.182)
	'''
	if channel_count == 1:
		return questionable_voltage_event_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_voltage_event_register[address]

#Status questionable voltage enable
def write_status_questionable_voltage_enable(par, ch):
	'''
	Change Questionable Enable Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-17 (p.182)
	'''
	global questionable_voltage_enable_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					questionable_voltage_enable_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_questionable_voltage_enable(ch, channel_count):
	'''
	Query the Questionable Enable Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-17 (p.182)
	'''
	if channel_count == 1:
		return questionable_voltage_enable_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_voltage_enable_register[address]

#Status questionable voltage condition
def read_status_questionable_voltage_condition(ch, channel_count):
	'''
	Query the Questionable Condition Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-17 (p.182)
	'''
	if channel_count == 1:
		return questionable_voltage_condition_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_voltage_condition_register[address]

#Status questionable voltage negative trans filter
def write_status_questionable_voltage_ntransition(par, ch):
	'''
	Change Questionable Negative Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-17 (p.182)
	'''
	global questionable_voltage_ntrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					questionable_voltage_ntrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_questionable_voltage_ntransition(ch, channel_count):
	'''
	Query the Questionable Negative Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-17 (p.182)
	'''
	if channel_count == 1:
		return questionable_voltage_ntrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_voltage_ntrans_register[address]

#Status questionable voltage positive trans filter
def write_status_questionable_voltage_ptransition(par, ch):
	'''
	Change Questionable Positibe Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-17 (p.182)
	'''
	global questionable_voltage_ptrans_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 65535:
				for i in ch:
					questionable_voltage_ptrans_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_questionable_voltage_ptransition(ch, channel_count):
	'''
	Query the Questionable Positive Trans Filter Register.
	See table 5-15 page 5-42 (page 168 in pdf). OBS! I think it actually is table 5-17 (p.182)
	'''
	if channel_count == 1:
		return questionable_voltage_ptrans_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return questionable_voltage_ptrans_register[address]

#Status standard event
def read_status_standard_event(ch, channel_count):
	'''
	Query the Standard Event Register.
	See table 5-10 page 5-32 (page 164 in pdf). OBS! I think it actually is table 5-11 (p.168)'
	
	Reading register clears it
	'''
	if channel_count == 1:
		byte = standard_event_register[ch[0]]
		standard_event_register[ch[0]] = 0
		status_byte_register[ch[0]] = status_byte_register[ch[0]] & 0b11011111
		return byte
	else:
		for i in ch:
			if i == address:
				byte = standard_event_register[address]
				status_byte_register[address] = status_byte_register[address] & 0b11011111
				standard_event_register[address] = 0
				
				return byte

#Status standard enable
def write_status_standard_enable(par, ch):
	'''
	Change Standard Enable Register.
	See table 5-10 page 5-32 (page 164 in pdf). OBS! I think it actually is table 5-11 (p.168)
	'''
	global standard_enable_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 255:
				for i in ch:
					standard_enable_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_standard_enable(ch, channel_count):
	'''
	Query the Standard Enable Register.
	See table 5-10 page 5-32 (page 164 in pdf). OBS! I think it actually is table 5-11 (p.168)
	'''
	if channel_count == 1:
		return standard_enable_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return standard_enable_register[address]

#Status byte event
def read_status_sbyte_event(ch, channel_count):
	'''
	Query the Status Byte Register.
	See table 5-10 page 5-32 (page 164 in pdf).
	
	I have not implemented anything activating register.
	'''
	if channel_count == 1:
		return status_byte_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return status_byte_register[address]

#Status srequest enable
def write_status_srequest_enable(par, ch):
	'''
	Service Request Enable register
	'''
	
	global srequest_enable_register
	
	if is_number(par):
		if float(par).is_integer():
			if 0 <= int(par) <= 255:
				for i in ch:
					srequest_enable_register[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
				
	err_syntax_error(ch)
	return None

def read_status_srequest_enable(ch, channel_count):
	if channel_count == 1:
		return srequest_enable_register[ch[0]]
	else:
		for i in ch:
			if i == address:
				return srequest_enable_register[address]
				
#Status clear			
def status_clear(ch, channel_count):
	'''
	Clear all the Status Data Strutures.
	'''
	global operation_condition_register, operation_enable_register, operation_event_register
	global operation_ntrans_register, operation_ptrans_register, operation_shutdown_condition_register
	global operation_shutdown_enable_register, operation_shutdown_event_register, operation_shutdown_ntrans_register
	global operation_shutdown_ptrans_register, operation_shutdown_protection_condition_register, operation_shutdown_protection_enable_register
	global operation_shutdown_protection_event_register, operation_shutdown_protection_ntrans_register 
	global operation_shutdown_protection_ptrans_register, operation_cshare_event_register, operation_cshare_enable_register
	global operation_cshare_condition_register, operation_cshare_ptrans_register, operation_cshare_ntrans_register
	global questionable_event_register, questionable_enable_register, questionable_condition_register
	global questionable_ntrans_register, questionable_ptrans_register, questionable_temperature_event_register
	global questionable_temperature_enable_register, questionable_temperature_condition_register, questionable_temperature_ntrans_register
	global questionable_temperature_ptrans_register, questionable_voltage_event_register, questionable_voltage_enable_register
	global questionable_voltage_condition_register, questionable_voltage_ntrans_register, questionable_voltage_ptrans_register
	global status_byte_register, standard_event_register, standard_enable_register, srequest_enable_register
	
	operation_condition_register = [0b0000000000000000] * 30
	operation_enable_register = [0b1111111111111111] * 30	#I set the enable registers back to all 1
															#not sure if that is correct
	operation_event_register = [0b0000000000000000] * 30
	operation_ntrans_register = [0b0000000000000000] * 30
	operation_ptrans_register = [0b0000000000000000] * 30
	operation_shutdown_condition_register = [0b0000] * 30
	operation_shutdown_enable_register = [0b1111] * 30
	operation_shutdown_event_register = [0b0000] * 30
	operation_shutdown_ntrans_register = [0b0000] * 30
	operation_shutdown_ptrans_register = [0b0000] * 30
	operation_shutdown_protection_condition_register = [0b000000000] * 30
	operation_shutdown_protection_enable_register = [0b111111111] * 30
	operation_shutdown_protection_event_register = [0b000000000] * 30
	operation_shutdown_protection_ntrans_register = [0b000000000] * 30
	operation_shutdown_protection_ptrans_register = [0b000000000] * 30
	operation_cshare_event_register = [0b00] * 30
	operation_cshare_enable_register = [0b11] * 30
	operation_cshare_condition_register = [0b00] * 30
	operation_cshare_ptrans_register = [0b00] * 30
	operation_cshare_ntrans_register = [0b00] * 30
	questionable_event_register = [0b000000000] * 30
	questionable_enable_register = [0b111111111] * 30
	questionable_condition_register = [0b000000000] * 30
	questionable_ntrans_register = [0b000000000] * 30
	questionable_ptrans_register = [0b000000000] * 30
	questionable_temperature_event_register = [0b0] * 30
	questionable_temperature_enable_register = [0b1] * 30
	questionable_temperature_condition_register = [0b0] * 30
	questionable_temperature_ntrans_register = [0b0] * 30
	questionable_temperature_ptrans_register = [0b0] * 30
	questionable_voltage_event_register = [0b00] * 30
	questionable_voltage_enable_register = [0b11] * 30
	questionable_voltage_condition_register = [0b00] * 30
	questionable_voltage_ntrans_register = [0b00] * 30
	questionable_voltage_ptrans_register = [0b00] * 30
	status_byte_register = [0b00000000] * 30
	standard_event_register = [0b00000000] * 30
	standard_enable_register = [0b11111111] * 30
	srequest_enable_register = [0b11111111] * 30
	
	return None


#Calibration input voltage
def write_calibration_input_analog_voltage(par, ch):
	global calibrate_input_voltage

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_input_voltage[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def read_calibration_input_analog_voltage(ch, channel_count):	#I do not know what this is supposed to return
	if channel_count == 1:
		return calibrate_input_voltage[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_input_voltage[address]

#Calibration input current
def write_calibration_input_analog_current(par, ch):
	global calibrate_input_current

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_input_current[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def read_calibration_input_analog_current(par, ch):	#I do not know what this is supposed to return
	if channel_count == 1:
		return calibrate_input_current[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_input_current[address]


#Calibration output voltage
def write_calibration_output_voltage(par, ch):
	global calibrate_output_voltage

	if is_number(par):	#Check if value is a number
		for i in ch:	#If all good change the values
			calibrate_output_voltage[i] = float(par)
		return None

	err_syntax_error(ch)
	return None


#Calibration output voltage analog
def write_calibration_output_voltage_analog(par, ch):
	global calibrate_voltage_analog

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_voltage_analog[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_output_voltage_analog_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_output_voltage_analog(ch, channel_count):
	if channel_count == 1:
		return calibrate_voltage_analog[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_voltage_analog[address]


#Calibration output voltage analog isolated
def write_calibration_output_voltage_analog_isolated(par, ch):
	global calibrate_voltage_isolated

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_voltage_isolated[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_output_voltage_analog_isolated_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_output_voltage_analog_isolated(ch, channel_count):
	if channel_count == 1:
		return calibrate_voltage_isolated[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_voltage_isolated[address]

#Calibration output voltage analog resisitive
def write_calibration_output_voltage_analog_resistive(par, ch):
	global calibrate_voltage_resistive

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_voltage_resistive[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_output_voltage_analog_resistive_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_output_voltage_analog_resistive(ch, channel_count):
	if channel_count == 1:
		return calibrate_voltage_resistive[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_voltage_resistive[address]

#Calibration output voltage analog resisitive isolated
def write_calibration_output_voltage_analog_resistive_isolated(par, ch):
	global calibrate_voltage_resistive_isolated

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_voltage_resistive_isolated[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_output_voltage_analog_resistive_isolated_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_output_voltage_analog_resistive_isolated(ch, channel_count):
	if channel_count == 1:
		return calibrate_voltage_resistive_isolated[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_voltage_resistive_isolated[address]


#Calibration output current
def write_calibration_output_current(par, ch):
	global calibrate_output_current

	if is_number(par):	#Check if value is a number
		for i in ch:	#If all good change the values
			calibrate_input_current[i] = float(par)
		return None

	err_syntax_error(ch)
	return None


#Calibration output current analog
def write_calibration_output_current_analog(par, ch):
	global calibrate_current_analog

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_current_analog[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_output_current_analog_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_output_current_analog(ch, channel_count):
	if channel_count == 1:
		return calibrate_current_analog[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_current_analog[address]


#Calibration output current analog isolated
def write_calibration_output_current_analog_isolated(par, ch):
	global calibrate_current_isolated

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_current_isolated[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_output_current_analog_isolated_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_output_current_analog_isolated(ch, channel_count):
	if channel_count == 1:
		return calibrate_current_isolated[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_current_isolated[address]

#Calibration output current analog resisitive
def write_calibration_output_current_analog_resistive(par, ch):
	global calibrate_current_resistive

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_current_resistive[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_output_current_analog_resistive_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_output_current_analog_resistive(ch, channel_count):
	if channel_count == 1:
		return calibrate_current_resistive[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_current_resistive[address]

#Calibration output current analog resisitive isolated
def write_calibration_output_current_analog_resistive_isolated(par, ch):
	global calibrate_current_resistive_isolated

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_current_resistive_isolated[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_output_current_analog_resistive_isolated_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_output_current_analog_resistive_isolated(ch, channel_count):
	if channel_count == 1:
		return calibrate_current_resistive_isolated[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_current_resistive_isolated[address]


#Calibration monitor voltage
def write_calibration_monitor_voltage(par, ch):
	global calibrate_monitor_voltage

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_monitor_voltage[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_monitor_voltage_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_monitor_voltage(ch, channel_count):
	if channel_count == 1:
		return calibrate_monitor_voltage[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_monitor_voltage[address]


#Calibration monitor voltage isolated
def write_calibration_monitor_voltage_isolated(par, ch):
	global calibrate_monitor_voltage_isolated

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_monitor_voltage_isolated[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_monitor_voltage_isolated_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_monitor_voltage_isolated(ch, channel_count):
	if channel_count == 1:
		return calibrate_monitor_voltage_isolated[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_monitor_voltage_isolated[address]


#Calibration monitor current
def write_calibration_monitor_current(par, ch):
	global calibrate_monitor_current

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_monitor_current[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_monitor_current_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_monitor_current(ch, channel_count):
	if channel_count == 1:
		return calibrate_monitor_current[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_monitor_current[address]


#Calibration monitor current isolated
def write_calibration_monitor_current_isolated(par, ch):
	global calibrate_monitor_current_isolated

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			for i in ch:	#If all good change the values
				calibrate_monitor_current_isolated[i] = int(par)
			return None

	err_syntax_error(ch)
	return None

def write_calibration_monitor_current_isolated_interactive(ch):	#Supposed to be interactive mode (press + or - to change value)
	return None

def read_calibration_monitor_current_isolated(ch, channel_count):
	if channel_count == 1:
		return calibrate_monitor_current_isolated[ch[0]]
	else:
		for i in ch:
			if i == address:
				return calibrate_monitor_current_isolated[address]


#Calibration store
def store_calibration(ch):	#Stores calibration to non-volatile memory location
	global stored_calibration

	for i in ch:
		stored_calibration[i][0] = calibrate_input_voltage[i]
		stored_calibration[i][1] = calibrate_output_voltage[i]
		stored_calibration[i][2] = calibrate_voltage_analog[i]
		stored_calibration[i][3] = calibrate_voltage_isolated[i]
		stored_calibration[i][4] = calibrate_voltage_resistive[i]
		stored_calibration[i][5] = calibrate_voltage_resistive_isolated[i]
		stored_calibration[i][6] = calibrate_monitor_voltage[i]
		stored_calibration[i][7] = calibrate_monitor_voltage_isolated[i]
		stored_calibration[i][8] = calibrate_input_current[i]
		stored_calibration[i][9] = calibrate_output_current[i]
		stored_calibration[i][10] = calibrate_current_analog[i]
		stored_calibration[i][11] = calibrate_current_isolated[i]
		stored_calibration[i][12] = calibrate_current_resistive[i]
		stored_calibration[i][13] = calibrate_current_resistive_isolated[i]
		stored_calibration[i][14] = calibrate_monitor_current[i]
		stored_calibration[i][15] = calibrate_monitor_current_isolated[i]

#Calibration restore
def restore_calibration(ch):	#Restores calibration to factory defaults (overwrites default saved data)
	global calibrate_input_voltage, calibrate_output_voltage, calibrate_voltage_analog
	global calibrate_voltage_isolated, calibrate_voltage_resistive, calibrate_voltage_resistive_isolated
	global calibrate_monitor_voltage, calibrate_monitor_voltage_isolated, calibrate_input_current
	global calibrate_output_current, calibrate_current_analog, calibrate_current_isolated
	global calibrate_current_resistive, calibrate_current_resistive_isolated, calibrate_monitor_current
	global calibrate_monitor_current_isolated, stored_calibration

	for i in ch:
		calibrate_input_voltage[i] = factory_calibration[i][0]
		calibrate_output_voltage[i] = factory_calibration[i][1]
		calibrate_voltage_analog[i] = factory_calibration[i][2]
		calibrate_voltage_isolated[i] = factory_calibration[i][3]
		calibrate_voltage_resistive[i] = factory_calibration[i][4]
		calibrate_voltage_resistive_isolated[i] = factory_calibration[i][5]
		calibrate_monitor_voltage[i] = factory_calibration[i][6]
		calibrate_monitor_voltage_isolated[i] = factory_calibration[i][7]
		calibrate_input_current[i] = factory_calibration[i][8]
		calibrate_output_current[i] = factory_calibration[i][9]
		calibrate_current_analog[i] = factory_calibration[i][10]
		calibrate_current_isolated[i] = factory_calibration[i][11]
		calibrate_current_resistive[i] = factory_calibration[i][12]
		calibrate_current_resistive_isolated[i] = factory_calibration[i][13]
		calibrate_monitor_current[i] = factory_calibration[i][14]
		calibrate_monitor_current_isolated[i] = factory_calibration[i][15]

	stored_calibration = copy.deepcopy(factory_calibration)

#Calibration default
def default_calibration(ch):	#Changes calibration to saved default values
	global calibrate_input_voltage, calibrate_output_voltage, calibrate_voltage_analog
	global calibrate_voltage_isolated, calibrate_voltage_resistive, calibrate_voltage_resistive_isolated
	global calibrate_monitor_voltage, calibrate_monitor_voltage_isolated, calibrate_input_current
	global calibrate_output_current, calibrate_current_analog, calibrate_current_isolated
	global calibrate_current_resistive, calibrate_current_resistive_isolated, calibrate_monitor_current
	global calibrate_monitor_current_isolated

	for i in ch:
		calibrate_input_voltage[i] = stored_calibration[i][0]
		calibrate_output_voltage[i] = stored_calibration[i][1]
		calibrate_voltage_analog[i] = stored_calibration[i][2]
		calibrate_voltage_isolated[i] = stored_calibration[i][3]
		calibrate_voltage_resistive[i] = stored_calibration[i][4]
		calibrate_voltage_resistive_isolated[i] = stored_calibration[i][5]
		calibrate_monitor_voltage[i] = stored_calibration[i][6]
		calibrate_monitor_voltage_isolated[i] = stored_calibration[i][7]
		calibrate_input_current[i] = stored_calibration[i][8]
		calibrate_output_current[i] = stored_calibration[i][9]
		calibrate_current_analog[i] = stored_calibration[i][10]
		calibrate_current_isolated[i] = stored_calibration[i][11]
		calibrate_current_resistive[i] = stored_calibration[i][12]
		calibrate_current_resistive_isolated[i] = stored_calibration[i][13]
		calibrate_monitor_current[i] = stored_calibration[i][14]
		calibrate_monitor_current_isolated[i] = stored_calibration[i][15]

#calibration overvoltage
def write_calibration_voltage_protection(par, ch):	#Enters self calibration
	return None


#Inititate autosequence
def initiate_autosequence(ch):	#Not implemented
	return None


#Sense protection interlock
def write_sense_protection(par, ch):	#Have not implemented effects of interlock system
	global interlock_system_state

	if is_number(par):
		if float(par) == 0 or float(par) == 1:
			for i in ch:
				interlock_system_state[i] = int(par)
			return None
	elif par == "ON" + TERMINATOR:
		for i in ch:
			interlock_system_state[i] = 1
		return None
	elif par == "OFF" + TERMINATOR:
		for i in ch:
			interlock_system_state[i] = 0
		return None

	err_syntax_error(ch)
	return None

def read_sense_protection(ch, channel_count):
	if channel_count == 1:
		return interlock_system_state[ch[0]]
	else:
		for i in ch:
			if i == address:
				return interlock_system_state[address]


#Program delete all		NOTE! Sequences not implemented!
def program_delete(ch):	
	'''
	Erases sequences currently in memory
	'''
	return None

#Program state
def write_program_state(par, ch):	#Access run state of sequence
	global sequence_state

	if par == "RUN" + TERMINATOR:	#Check if value is a number
		for i in ch:	#If all good change the values
			sequence_state[i] = "RUN"
		return None
	elif par == "STOP" + TERMINATOR:	#Check if value is a number
		for i in ch:	#If all good change the values
			sequence_state[i] = "STOP"
		return None
	elif par == "PAUSE" + TERMINATOR:	#Check if value is a number
		for i in ch:	#If all good change the values
			sequence_state[i] = "PAUSE"
		return None

	err_syntax_error(ch)
	return None

def read_program_state(ch, channel_count):
	if channel_count == 1:
		return sequence_state[ch[0]]
	else:
		for i in ch:
			if i == address:
				return sequence_state[address]

#Program repeat
def write_program_repeat(par, ch):
	global sequence_repeat

	if is_number(par):	#Check if value is a number
		if float(par).is_integer():
			if 1 <= int(par) <= 65534:
				for i in ch:	#If all good change the values
					sequence_repeat[i] = int(par)
				return None
			else:
				err_data_out_of_range(ch)
				return None
		elif float(par) == float("inf"):
			for i in ch:	#If all good change the values
				sequence_repeat[i] = float(par)
			return None

	err_syntax_error(ch)
	return None

def read_program_repeat(ch, channel_count):
	if channel_count == 1:
		return sequence_repeat[ch[0]]
	else:
		for i in ch:
			if i == address:
				return sequence_repeat[address]

#Program record start
def program_record_start(ch):
	'''
	Start recording new squence - overwrites old
	'''
	return None

#Program record stop
def program_record_stop(ch):
	'''
	Stop recording auto sequence program
	'''
	return None

#Program step dwel
def write_program_step_dwel(par, ch):
	'''
	Sets time delay between commands in sequence
	'''
	global sequence_dwel

	if is_number(par):	#Check if value is a number
		for i in ch:	#If all good change the values
			sequence_dwel[i] = float(par)
		return None

	err_syntax_error(ch)
	return None

def read_program_step_dwel(ch, channel_count):
	if channel_count == 1:
		return sequence_dwel[ch[0]]
	else:
		for i in ch:
			if i == address:
				return sequence_dwel[address]

#Program readback
def read_program_readback(ch, channel_count):	#Don't know what it is supposed to return, maybe commands in sequence
	return "I assume this is supposed to list commands in sequence"




####################################################################################################
# Functions for if statements
####################################################################################################

#Fcn used to check if a character is a number
def is_number(s):
	try:
		float(s)
		return True
	except ValueError:
		return False

def source_bool(comm, key):	#Check if we enter the source subsystem
	if key & 001:
		if comm == "SOUR": return True
		if comm == "SOURCE": return True
		if comm == "SOUR" + TERMINATOR: return True
		if comm == "SOURCE" + TERMINATOR: return True
		if comm == " SOUR": return True
		if comm == " SOURCE": return True
		if comm == " SOUR" + TERMINATOR: return True
		if comm == " SOURCE" + TERMINATOR: return True
	if key & 010:
		if comm == "SOUR?": return True
		if comm == "SOURCE?": return True
		if comm == "SOUR?" + TERMINATOR: return True
		if comm == "SOURCE?" + TERMINATOR: return True
		if comm == " SOUR?": return True
		if comm == " SOURCE?": return True
		if comm == " SOUR?" + TERMINATOR: return True
		if comm == " SOURCE?" + TERMINATOR: return True
	return False

def combine_bool(comm, key):
	if key & 001:	#Enter if key is 1 or 9
		if comm == "COMB": return True
		if comm == "COMBINE": return True
		if comm == "COMB" + TERMINATOR: return True
		if comm == "COMBINE" + TERMINATOR: return True
		if comm == " COMB": return True
		if comm == " COMBINE": return True
		if comm == " COMB" + TERMINATOR: return True
		if comm == " COMBINE" + TERMINATOR: return True
	if key & 010:	#Enter if key is 8 or 9
		if comm == "COMB?": return True
		if comm == "COMBINE?": return True
		if comm == "COMB?" + TERMINATOR: return True
		if comm == "COMBINE?" + TERMINATOR: return True
		if comm == " COMB?": return True
		if comm == " COMBINE?": return True
		if comm == " COMB?" + TERMINATOR: return True
		if comm == " COMBINE?" + TERMINATOR: return True
	return False

def cshare_bool(comm, key):
	if key & 001:
		if comm == "CSH": return True
		if comm == "CSHARE": return True
		if comm == "CSH" + TERMINATOR: return True
		if comm == "CSHARE" + TERMINATOR: return True
		if comm == " CSH": return True
		if comm == " CSHARE": return True
		if comm == " CSH" + TERMINATOR: return True
		if comm == " CSHARE" + TERMINATOR: return True
	if key & 010:
		if comm == "CSH?": return True
		if comm == "CSHARE?": return True
		if comm == "CSH?" + TERMINATOR: return True
		if comm == "CSHARE?" + TERMINATOR: return True
		if comm == " CSH?": return True
		if comm == " CSHARE?": return True
		if comm == " CSH?" + TERMINATOR: return True
		if comm == " CSHARE?" + TERMINATOR: return True
	return False

def mode_bool(comm, key):
	if key & 001:
		if comm == "MODE": return True
		if comm == "MODE" + TERMINATOR: return True
		if comm == " MODE": return True
		if comm == " MODE" + TERMINATOR: return True
	if key & 010:
		if comm == "MODE?": return True
		if comm == "MODE?" + TERMINATOR: return True
		if comm == " MODE?": return True
		if comm == " MODE?" + TERMINATOR: return True
	return False

def current_bool(comm, key):
	if key & 001:
		if comm == "CURR": return True
		if comm == "CURRENT": return True
		if comm == "CURR" + TERMINATOR: return True
		if comm == "CURRENT" + TERMINATOR: return True
		if comm == " CURR": return True
		if comm == " CURRENT": return True
		if comm == " CURR" + TERMINATOR: return True
		if comm == " CURRENT" + TERMINATOR: return True
	if key & 010:
		if comm == "CURR?": return True
		if comm == "CURRENT?": return True
		if comm == "CURR?" + TERMINATOR: return True
		if comm == "CURRENT?" + TERMINATOR: return True
		if comm == " CURR?": return True
		if comm == " CURRENT?": return True
		if comm == " CURR?" + TERMINATOR: return True
		if comm == " CURRENT?" + TERMINATOR: return True
	return False

def power_bool(comm, key):
	if key & 001:
		if comm == "POW": return True
		if comm == "POWER": return True
		if comm == "POW" + TERMINATOR: return True
		if comm == "POWER" + TERMINATOR: return True
		if comm == " POW": return True
		if comm == " POWER": return True
		if comm == " POW" + TERMINATOR: return True
		if comm == " POWER" + TERMINATOR: return True
	if key & 010:
		if comm == "POW?": return True
		if comm == "POWER?": return True
		if comm == "POW?" + TERMINATOR: return True
		if comm == "POWER?" + TERMINATOR: return True
		if comm == " POW?": return True
		if comm == " POWER?": return True
		if comm == " POW?" + TERMINATOR: return True
		if comm == " POWER?" + TERMINATOR: return True
	return False

def auxilliary_bool(comm, key):
	if key & 001:
		if comm == "AUX": return True
		if comm == "AUXILLIARY": return True
		if comm == "AUX" + TERMINATOR: return True
		if comm == "AUXILLIARY" + TERMINATOR: return True
		if comm == " AUX": return True
		if comm == " AUXILLIARY": return True
		if comm == " AUX" + TERMINATOR: return True
		if comm == " AUXILLIARY" + TERMINATOR: return True
	if key & 010:
		if comm == "AUX?": return True
		if comm == "AUXILLIARY?": return True
		if comm == "AUX?" + TERMINATOR: return True
		if comm == "AUXILLIARY?" + TERMINATOR: return True
		if comm == " AUX?": return True
		if comm == " AUXILLIARY?": return True
		if comm == " AUX?" + TERMINATOR: return True
		if comm == " AUXILLIARY?" + TERMINATOR: return True
	return False

def protection_bool(comm, key):
	if key & 001:
		if comm == "PROT": return True
		if comm == "PROTECTION": return True
		if comm == "PROT" + TERMINATOR: return True
		if comm == "PROTECTION" + TERMINATOR: return True
		if comm == " PROT": return True
		if comm == " PROTECTION": return True
		if comm == " PROT" + TERMINATOR: return True
		if comm == " PROTECTION" + TERMINATOR: return True
	if key & 010:
		if comm == "PROT?": return True
		if comm == "PROTECTION?": return True
		if comm == "PROT?" + TERMINATOR: return True
		if comm == "PROTECTION?" + TERMINATOR: return True
		if comm == " PROT?": return True
		if comm == " PROTECTION?": return True
		if comm == " PROT?" + TERMINATOR: return True
		if comm == " PROTECTION?" + TERMINATOR: return True
	return False

def overvoltage_bool(comm, key):
	if key & 001:
		if comm == "OVER": return True
		if comm == "OVERVOLTAGE": return True
		if comm == "OVER" + TERMINATOR: return True
		if comm == "OVERVOLTAGE" + TERMINATOR: return True
		if comm == " OVER": return True
		if comm == " OVERVOLTAGE": return True
		if comm == " OVER" + TERMINATOR: return True
		if comm == " OVERVOLTAGE" + TERMINATOR: return True
	if key & 010:
		if comm == "OVER?": return True
		if comm == "OVERVOLTAGE?": return True
		if comm == "OVER?" + TERMINATOR: return True
		if comm == "OVERVOLTAGE?" + TERMINATOR: return True
		if comm == " OVER?": return True
		if comm == " OVERVOLTAGE?": return True
		if comm == " OVER?" + TERMINATOR: return True
		if comm == " OVERVOLTAGE?" + TERMINATOR: return True
	return False

def under_bool(comm, key):
	if key & 001:
		if comm == "UND": return True
		if comm == "UNDER": return True
		if comm == "UND" + TERMINATOR: return True
		if comm == "UNDER" + TERMINATOR: return True
		if comm == " UND": return True
		if comm == " UNDER": return True
		if comm == " UND" + TERMINATOR: return True
		if comm == " UNDER" + TERMINATOR: return True
	if key & 010:
		if comm == "UND?": return True
		if comm == "UNDER?": return True
		if comm == "UND?" + TERMINATOR: return True
		if comm == "UNDER?" + TERMINATOR: return True
		if comm == " UND?": return True
		if comm == " UNDER?": return True
		if comm == " UND?" + TERMINATOR: return True
		if comm == " UNDER?" + TERMINATOR: return True
	return False

def source_optional_commands(comm, key):
	if key & 0000001:	#Enter if key correct key
		if comm == "LEV": return True
		if comm == "LEVEL": return True
		if comm == "LEV" + TERMINATOR: return True
		if comm == "LEVEL" + TERMINATOR: return True
		if comm == " LEV": return True
		if comm == " LEVEL": return True
		if comm == " LEV" + TERMINATOR: return True
		if comm == " LEVEL" + TERMINATOR: return True
	if key & 0000010:
		if comm == "IMM": return True
		if comm == "IMMEDIATE": return True
		if comm == "IMM" + TERMINATOR: return True
		if comm == "IMMEDIATE" + TERMINATOR: return True
		if comm == " IMM": return True
		if comm == " IMMEDIATE": return True
		if comm == " IMM" + TERMINATOR: return True
		if comm == " IMMEDIATE" + TERMINATOR: return True
	if key & 0000100:
		if comm == "AMPL": return True
		if comm == "AMPLITUDE": return True
		if comm == "AMPL" + TERMINATOR: return True
		if comm == "AMPLITUDE" + TERMINATOR: return True
		if comm == " AMPL": return True
		if comm == " AMPLITUDE": return True
		if comm == " AMPL" + TERMINATOR: return True
		if comm == " AMPLITUDE" + TERMINATOR: return True
	if key & 0001000:
		if comm == "LEV?": return True
		if comm == "LEVEL?": return True
		if comm == "LEV?" + TERMINATOR: return True
		if comm == "LEVEL?" + TERMINATOR: return True
		if comm == " LEV?": return True
		if comm == " LEVEL?": return True
		if comm == " LEV?" + TERMINATOR: return True
		if comm == " LEVEL?" + TERMINATOR: return True
	if key & 0010000:
		if comm == "IMM?": return True
		if comm == "IMMEDIATE?": return True
		if comm == "IMM?" + TERMINATOR: return True
		if comm == "IMMEDIATE?" + TERMINATOR: return True
	if key & 0100000:
		if comm == "AMPL?": return True
		if comm == "AMPLITUDE?": return True
		if comm == "AMPL?" + TERMINATOR: return True
		if comm == "AMPLITUDE?" + TERMINATOR: return True
		if comm == " AMPL?": return True
		if comm == " AMPLITUDE?": return True
		if comm == " AMPL?" + TERMINATOR: return True
		if comm == " AMPLITUDE?" + TERMINATOR: return True
	return False

def maximum_bool(comm, key):
	if key & 001:
		if comm == "MAX": return True
		if comm == "MAXIMUM": return True
		if comm == "MAX" + TERMINATOR: return True
		if comm == "MAXIMUM" + TERMINATOR: return True
		if comm == " MAX": return True
		if comm == " MAXIMUM": return True
		if comm == " MAX" + TERMINATOR: return True
		if comm == " MAXIMUM" + TERMINATOR: return True
	if key & 010:
		if comm == "MAX?": return True
		if comm == "MAXIMUM?": return True
		if comm == "MAX?" + TERMINATOR: return True
		if comm == "MAXIMUM?" + TERMINATOR: return True
		if comm == " MAX?": return True
		if comm == " MAXIMUM?": return True
		if comm == " MAX?" + TERMINATOR: return True
		if comm == " MAXIMUM?" + TERMINATOR: return True
	return False

def minimum_bool(comm, key):
	if key & 001:
		if comm == "MIN": return True
		if comm == "MINIMUM": return True
		if comm == "MIN" + TERMINATOR: return True
		if comm == "MINIMUM" + TERMINATOR: return True
		if comm == " MIN": return True
		if comm == " MINIMUM": return True
		if comm == " MIN" + TERMINATOR: return True
		if comm == " MINIMUM" + TERMINATOR: return True
	if key & 010:
		if comm == "MIN?": return True
		if comm == "MINIMUM?": return True
		if comm == "MIN?" + TERMINATOR: return True
		if comm == "MINIMUM?" + TERMINATOR: return True
		if comm == " MIN?": return True
		if comm == " MINIMUM?": return True
		if comm == " MIN?" + TERMINATOR: return True
		if comm == " MINIMUM?" + TERMINATOR: return True
	return False

def aprogram_bool(comm, key):
	if key & 001:
		if comm == "APR": return True
		if comm == "APROGRAM": return True
		if comm == "APR" + TERMINATOR: return True
		if comm == "APROGRAM" + TERMINATOR: return True
		if comm == " APR": return True
		if comm == " APROGRAM": return True
		if comm == " APR" + TERMINATOR: return True
		if comm == " APROGRAM" + TERMINATOR: return True
	if key & 010:
		if comm == "APR?": return True
		if comm == "APROGRAM?": return True
		if comm == "APR?" + TERMINATOR: return True
		if comm == "APROGRAM?" + TERMINATOR: return True
		if comm == " APR?": return True
		if comm == " APROGRAM?": return True
		if comm == " APR?" + TERMINATOR: return True
		if comm == " APROGRAM?" + TERMINATOR: return True
	return False
	
def mchannel_bool(comm, key):
	if key & 001:
		if comm == "MCH": return True
		if comm == "MCHANNEL": return True
		if comm == "MCH" + TERMINATOR: return True
		if comm == "MCHANNEL" + TERMINATOR: return True
		if comm == " MCH": return True
		if comm == " MCHANNEL": return True
		if comm == " MCH" + TERMINATOR: return True
		if comm == " MCHANNEL" + TERMINATOR: return True
	if key & 010:
		if comm == "MCH?": return True
		if comm == "MCHANNEL?": return True
		if comm == "MCH?" + TERMINATOR: return True
		if comm == "MCHANNEL?" + TERMINATOR: return True
		if comm == " MCH?": return True
		if comm == " MCHANNEL?": return True
		if comm == " MCH?" + TERMINATOR: return True
		if comm == " MCHANNEL?" + TERMINATOR: return True
	return False
	
def address_bool(comm, key):
	if key & 001:
		if comm == "ADDR": return True
		if comm == "ADDRESS": return True
		if comm == "ADDR" + TERMINATOR: return True
		if comm == "ADDRESS" + TERMINATOR: return True
		if comm == " ADDR": return True
		if comm == " ADDRESS": return True
		if comm == " ADDR" + TERMINATOR: return True
		if comm == " ADDRESS" + TERMINATOR: return True
	if key & 010:
		if comm == "ADDR?": return True
		if comm == "ADDRESS?": return True
		if comm == "ADDR?" + TERMINATOR: return True
		if comm == "ADDRESS?" + TERMINATOR: return True
		if comm == " ADDR?": return True
		if comm == " ADDRESS?": return True
		if comm == " ADDR?" + TERMINATOR: return True
		if comm == " ADDRESS?" + TERMINATOR: return True
	return False

def scalar_bool(comm, key):
	if key & 001:
		if comm == "SCAL": return True
		if comm == "SCALAR": return True
		if comm == "SCAL" + TERMINATOR: return True
		if comm == "SCALAR" + TERMINATOR: return True
		if comm == " SCAL": return True
		if comm == " SCALAR": return True
		if comm == " SCAL" + TERMINATOR: return True
		if comm == " SCALAR" + TERMINATOR: return True
	if key & 010:
		if comm == "SCAL?": return True
		if comm == "SCALAR?": return True
		if comm == "SCAL?" + TERMINATOR: return True
		if comm == "SCALAR?" + TERMINATOR: return True
		if comm == " SCAL?": return True
		if comm == " SCALAR?": return True
		if comm == " SCAL?" + TERMINATOR: return True
		if comm == " SCALAR?" + TERMINATOR: return True
	return False

def dc_bool(comm, key):
	if key & 001:
		if comm == "DC": return True
		if comm == "DC" + TERMINATOR: return True
		if comm == " DC": return True
		if comm == " DC" + TERMINATOR: return True
	if key & 010:
		if comm == "DC?": return True
		if comm == "DC?" + TERMINATOR: return True
		if comm == " DC?": return True
		if comm == " DC?" + TERMINATOR: return True
	return False

def all_bool(comm, key):
	if key & 001:
		if comm == "ALL": return True
		if comm == "ALL" + TERMINATOR: return True
		if comm == " ALL": return True
		if comm == " ALL" + TERMINATOR: return True
	if key & 010:
		if comm == "ALL?": return True
		if comm == "ALL?" + TERMINATOR: return True
		if comm == " ALL?": return True
		if comm == " ALL?" + TERMINATOR: return True
	return False

def analog_bool(comm, key):
	if key & 001:
		if comm ==  "ANAL": return True
		if comm ==  "ANALOG": return True
		if comm ==  "ANAL" + TERMINATOR: return True
		if comm ==  "ANALOG" + TERMINATOR: return True
		if comm ==  " ANAL": return True
		if comm ==  " ANALOG": return True
		if comm ==  " ANAL" + TERMINATOR: return True
		if comm ==  " ANALOG" + TERMINATOR: return True
	if key & 010:
		if comm ==  "ANAL?": return True
		if comm ==  "ANALOG?": return True
		if comm ==  "ANAL?" + TERMINATOR: return True
		if comm ==  "ANALOG?" + TERMINATOR: return True
		if comm ==  " ANAL?": return True
		if comm ==  " ANALOG?": return True
		if comm ==  " ANAL?" + TERMINATOR: return True
		if comm ==  " ANALOG?" + TERMINATOR: return True
	return False

def resistive_bool(comm, key):
	if key & 001:
		if comm == "RES": return True
		if comm == "RESISTIVE": return True
		if comm == "RES" + TERMINATOR: return True
		if comm == "RESISTIVE" + TERMINATOR: return True
		if comm == " RES": return True
		if comm == " RESISTIVE": return True
		if comm == " RES" + TERMINATOR: return True
		if comm == " RESISTIVE" + TERMINATOR: return True
	if key & 010:
		if comm == "RES?": return True
		if comm == "RESISTIVE?": return True
		if comm == "RES?" + TERMINATOR: return True
		if comm == "RESISTIVE?" + TERMINATOR: return True
		if comm == " RES?": return True
		if comm == " RESISTIVE?": return True
		if comm == " RES?" + TERMINATOR: return True
		if comm == " RESISTIVE?" + TERMINATOR: return True
	return False

def input_bool(comm, key):
	if key & 001:
		if comm == "INP": return True
		if comm == "INPUT": return True
		if comm == "INP" + TERMINATOR: return True
		if comm == "INPUT" + TERMINATOR: return True
		if comm == " INP": return True
		if comm == " INPUT": return True
		if comm == " INP" + TERMINATOR: return True
		if comm == " INPUT" + TERMINATOR: return True
	if key & 010:
		if comm == "INP?": return True
		if comm == "INPUT?": return True
		if comm == "INP?" + TERMINATOR: return True
		if comm == "INPUT?" + TERMINATOR: return True
		if comm == " INP?": return True
		if comm == " INPUT?": return True
		if comm == " INP?" + TERMINATOR: return True
		if comm == " INPUT?" + TERMINATOR: return True
	return False

def monitor_bool(comm, key):
	if key & 001:
		if comm == "MON": return True
		if comm == "MONITOR": return True
		if comm == "MON" + TERMINATOR: return True
		if comm == "MONITOR" + TERMINATOR: return True
		if comm == " MON": return True
		if comm == " MONITOR": return True
		if comm == " MON" + TERMINATOR: return True
		if comm == " MONITOR" + TERMINATOR: return True
	if key & 010:
		if comm == "MON?": return True
		if comm == "MONITOR?": return True
		if comm == "MON?" + TERMINATOR: return True
		if comm == "MONITOR?" + TERMINATOR: return True
		if comm == " MON?": return True
		if comm == " MONITOR?": return True
		if comm == " MON?" + TERMINATOR: return True
		if comm == " MONITOR?" + TERMINATOR: return True
	return False

def default_bool(comm, key):
	if key & 001:
		if comm == "DEF": return True
		if comm == "DEFAULT": return True
		if comm == "DEF" + TERMINATOR: return True
		if comm == "DEFAULT" + TERMINATOR: return True
		if comm == " DEF": return True
		if comm == " DEFAULT": return True
		if comm == " DEF" + TERMINATOR: return True
		if comm == " DEFAULT" + TERMINATOR: return True
	if key & 010:
		if comm == "DEF?": return True
		if comm == "DEFAULT?": return True
		if comm == "DEF?" + TERMINATOR: return True
		if comm == "DEFAULT?" + TERMINATOR: return True
		if comm == " DEF?": return True
		if comm == " DEFAULT?": return True
		if comm == " DEF?" + TERMINATOR: return True
		if comm == " DEFAULT?" + TERMINATOR: return True
	return False

def over_bool(comm, key):
	if key & 001:
		if comm == "OVER": return True
		if comm == "OVER" + TERMINATOR: return True
		if comm == " OVER": return True
		if comm == " OVER" + TERMINATOR: return True
	if key & 010:
		if comm == "OVER?": return True
		if comm == "OVER?" + TERMINATOR: return True
		if comm == " OVER?": return True
		if comm == " OVER?" + TERMINATOR: return True
	return False

def clear_bool(comm, key):
	if key & 001:
		if comm == "CLE": return True
		if comm == "CLEAR": return True
		if comm == "CLE" + TERMINATOR: return True
		if comm == "CLEAR" + TERMINATOR: return True
		if comm == " CLE": return True
		if comm == " CLEAR": return True
		if comm == " CLE" + TERMINATOR: return True
		if comm == " CLEAR" + TERMINATOR: return True
	if key & 010:
		if comm == "CLE?": return True
		if comm == "CLEAR?": return True
		if comm == "CLE?" + TERMINATOR: return True
		if comm == "CLEAR?" + TERMINATOR: return True
		if comm == " CLE?": return True
		if comm == " CLEAR?": return True
		if comm == " CLE?" + TERMINATOR: return True
		if comm == " CLEAR?" + TERMINATOR: return True
	return False

def timeout_bool(comm, key):
	if key & 001:
		if comm == "TIM": return True
		if comm == "TIMEOUT": return True
		if comm == "TIM" + TERMINATOR: return True
		if comm == "TIMEOUT" + TERMINATOR: return True
		if comm == " TIM": return True
		if comm == " TIMEOUT": return True
		if comm == " TIM" + TERMINATOR: return True
		if comm == " TIMEOUT" + TERMINATOR: return True
	if key & 010:
		if comm == "TIM?": return True
		if comm == "TIMEOUT?": return True
		if comm == "TIM?" + TERMINATOR: return True
		if comm == "TIMEOUT?" + TERMINATOR: return True
		if comm == " TIM?": return True
		if comm == " TIMEOUT?": return True
		if comm == " TIM?" + TERMINATOR: return True
		if comm == " TIMEOUT?" + TERMINATOR: return True
	return False

def voltage_bool(comm, key):	#Check if we enter the voltage subsystem
	if key & 001:
		if comm == "VOLT": return True
		if comm == "VOLTAGE": return True
		if comm == "VOLT" + TERMINATOR: return True
		if comm == "VOLTAGE" + TERMINATOR: return True
		if comm == " VOLT": return True
		if comm == " VOLTAGE": return True
		if comm == " VOLT" + TERMINATOR: return True
		if comm == " VOLTAGE" + TERMINATOR: return True
	if key & 010:
		if comm == "VOLT?": return True
		if comm == "VOLTAGE?": return True
		if comm == "VOLT?" + TERMINATOR: return True
		if comm == "VOLTAGE?" + TERMINATOR: return True
		if comm == " VOLT?": return True
		if comm == " VOLTAGE?": return True
		if comm == " VOLT?" + TERMINATOR: return True
		if comm == " VOLTAGE?" + TERMINATOR: return True
	return False

def state_bool(comm, key):
	if key & 001:
		if comm == "STAT": return True
		if comm == "STATE": return True
		if comm == "STAT" + TERMINATOR: return True
		if comm == "STATE" + TERMINATOR: return True
		if comm == " STAT": return True
		if comm == " STATE": return True
		if comm == " STAT" + TERMINATOR: return True
		if comm == " STATE" + TERMINATOR: return True
	if key & 010:
		if comm == "STAT?": return True
		if comm == "STATE?": return True
		if comm == "STAT?" + TERMINATOR: return True
		if comm == "STATE?" + TERMINATOR: return True
		if comm == " STAT?": return True
		if comm == " STATE?": return True
		if comm == " STAT?" + TERMINATOR: return True
		if comm == " STATE?" + TERMINATOR: return True
	return False

def pon_bool(comm, key):
	if key & 001:
		if comm == "PON": return True
		if comm == "PON" + TERMINATOR: return True
		if comm == " PON": return True
		if comm == " PON" + TERMINATOR: return True
	if key & 010:
		if comm == "PON?": return True
		if comm == "PON?" + TERMINATOR: return True
		if comm == " PON?": return True
		if comm == " PON?" + TERMINATOR: return True
	return False

def measure_bool(comm, key):
	if key & 001:
		if comm == "MEAS": return True
		if comm == "MEASURED": return True
		if comm == "MEAS" + TERMINATOR: return True
		if comm == "MEASURED" + TERMINATOR: return True
		if comm == " MEAS": return True
		if comm == " MEASURED": return True
		if comm == " MEAS" + TERMINATOR: return True
		if comm == " MEASURED" + TERMINATOR: return True
	if key & 010:
		if comm == "MEAS?": return True
		if comm == "MEASURED?": return True
		if comm == "MEAS?" + TERMINATOR: return True
		if comm == "MEASURED?" + TERMINATOR: return True
		if comm == " MEAS?": return True
		if comm == " MEASURED?": return True
		if comm == " MEAS?" + TERMINATOR: return True
		if comm == " MEASURED?" + TERMINATOR: return True
	return False

def output_bool(comm, key):
	if key & 001:
		if comm == "OUTP": return True
		if comm == "OUTPUT": return True
		if comm == "OUTP" + TERMINATOR: return True
		if comm == "OUTPUT" + TERMINATOR: return True
		if comm == " OUTP": return True
		if comm == " OUTPUT": return True
		if comm == " OUTP" + TERMINATOR: return True
		if comm == " OUTPUT" + TERMINATOR: return True
	if key & 010:
		if comm == "OUTP?": return True
		if comm == "OUTPUT?": return True
		if comm == "OUTP?" + TERMINATOR: return True
		if comm == "OUTPUT?" + TERMINATOR: return True
		if comm == " OUTP?": return True
		if comm == " OUTPUT?": return True
		if comm == " OUTP?" + TERMINATOR: return True
		if comm == " OUTPUT?" + TERMINATOR: return True
	return False

def isolated_bool(comm, key):
	if key & 001:
		if comm == "ISOL": return True
		if comm == "ISOLATED": return True
		if comm == "ISOL" + TERMINATOR: return True
		if comm == "ISOLATED" + TERMINATOR: return True
		if comm == " ISOL": return True
		if comm == " ISOLATED": return True
		if comm == " ISOL" + TERMINATOR: return True
		if comm == " ISOLATED" + TERMINATOR: return True
	if key & 010:
		if comm == "ISOL?": return True
		if comm == "ISOLATED?": return True
		if comm == "ISOL?" + TERMINATOR: return True
		if comm == "ISOLATED?" + TERMINATOR: return True
		if comm == " ISOL?": return True
		if comm == " ISOLATED?": return True
		if comm == " ISOL?" + TERMINATOR: return True
		if comm == " ISOLATED?" + TERMINATOR: return True
	return False

def polarity_bool(comm, key):
	if key & 001:
		if comm == "POL": return True
		if comm == "POLARITY": return True
		if comm == "POL" + TERMINATOR: return True
		if comm == "POLARITY" + TERMINATOR: return True
		if comm == " POL": return True
		if comm == " POLARITY": return True
		if comm == " POL" + TERMINATOR: return True
		if comm == " POLARITY" + TERMINATOR: return True
	if key & 010:
		if comm == "POL?": return True
		if comm == "POLARITY?": return True
		if comm == "POL?" + TERMINATOR: return True
		if comm == "POLARITY?" + TERMINATOR: return True
		if comm == " POL?": return True
		if comm == " POLARITY?": return True
		if comm == " POL?" + TERMINATOR: return True
		if comm == " POLARITY?" + TERMINATOR: return True
	return False

def sense_bool(comm, key):
	if key & 001:
		if comm == "SENS": return True
		if comm == "SENSE": return True
		if comm == "SENS" + TERMINATOR: return True
		if comm == "SENSE" + TERMINATOR: return True
		if comm == " SENS": return True
		if comm == " SENSE": return True
		if comm == " SENS" + TERMINATOR: return True
		if comm == " SENSE" + TERMINATOR: return True
	if key & 010:
		if comm == "SENS?": return True
		if comm == "SENSE?": return True
		if comm == "SENS?" + TERMINATOR: return True
		if comm == "SENSE?" + TERMINATOR: return True
		if comm == " SENS?": return True
		if comm == " SENSE?": return True
		if comm == " SENS?" + TERMINATOR: return True
		if comm == " SENSE?" + TERMINATOR: return True
	return False

def delay_bool(comm, key):
	if key & 001:
		if comm == "DEL": return True
		if comm == "DELAY": return True
		if comm == "DEL" + TERMINATOR: return True
		if comm == "DELAY" + TERMINATOR: return True
		if comm == " DEL": return True
		if comm == " DELAY": return True
		if comm == " DEL" + TERMINATOR: return True
		if comm == " DELAY" + TERMINATOR: return True
	if key & 010:
		if comm == "DEL?": return True
		if comm == "DELAY?": return True
		if comm == "DEL?" + TERMINATOR: return True
		if comm == "DELAY?" + TERMINATOR: return True
		if comm == " DEL?": return True
		if comm == " DELAY?": return True
		if comm == " DEL?" + TERMINATOR: return True
		if comm == " DELAY?" + TERMINATOR: return True
	return False

def foldback_bool(comm, key):
	if key & 001:
		if comm == "FOLD": return True
		if comm == "FOLDBACK": return True
		if comm == "FOLD" + TERMINATOR: return True
		if comm == "FOLDBACK" + TERMINATOR: return True
		if comm == " FOLD": return True
		if comm == " FOLDBACK": return True
		if comm == " FOLD" + TERMINATOR: return True
		if comm == " FOLDBACK" + TERMINATOR: return True
	if key & 010:
		if comm == "FOLD?": return True
		if comm == "FOLDBACK?": return True
		if comm == "FOLD?" + TERMINATOR: return True
		if comm == "FOLDBACK?" + TERMINATOR: return True
		if comm == " FOLD?": return True
		if comm == " FOLDBACK?": return True
		if comm == " FOLD?" + TERMINATOR: return True
		if comm == " FOLDBACK?" + TERMINATOR: return True
	return False

def status_bool(comm, key):
	if key & 001:
		if comm == "STAT": return True
		if comm == "STATUS": return True
		if comm == "STAT" + TERMINATOR: return True
		if comm == "STATUS" + TERMINATOR: return True
		if comm == " STAT": return True
		if comm == " STATUS": return True
		if comm == " STAT" + TERMINATOR: return True
		if comm == " STATUS" + TERMINATOR: return True
	if key & 010:
		if comm == " STAT?": return True
		if comm == " STATUS?": return True
		if comm == " STAT?" + TERMINATOR: return True
		if comm == " STATUS?" + TERMINATOR: return True
	return False

def operation_bool(comm, key):
	if key & 001:
		if comm == "OPER": return True
		if comm == "OPERATION": return True
		if comm == "OPER" + TERMINATOR: return True
		if comm == "OPERATION" + TERMINATOR: return True
		if comm == " OPER": return True
		if comm == " OPERATION": return True
		if comm == " OPER" + TERMINATOR: return True
		if comm == " OPERATION" + TERMINATOR: return True
	if key & 010:
		if comm == "OPER?": return True
		if comm == "OPERATION?": return True
		if comm == "OPER?" + TERMINATOR: return True
		if comm == "OPERATION?" + TERMINATOR: return True
		if comm == " OPER?": return True
		if comm == " OPERATION?": return True
		if comm == " OPER?" + TERMINATOR: return True
		if comm == " OPERATION?" + TERMINATOR: return True
	return False

def condition_bool(comm, key):
	if key & 001:
		if comm == "COND": return True
		if comm == "CONDITION": return True
		if comm == "COND" + TERMINATOR: return True
		if comm == "CONDITION" + TERMINATOR: return True
		if comm == " COND": return True
		if comm == " CONDITION": return True
		if comm == " COND" + TERMINATOR: return True
		if comm == " CONDITION" + TERMINATOR: return True
	if key & 010:
		if comm == "COND?": return True
		if comm == "CONDITION?": return True
		if comm == "COND?" + TERMINATOR: return True
		if comm == "CONDITION?" + TERMINATOR: return True
		if comm == " COND?": return True
		if comm == " CONDITION?": return True
		if comm == " COND?" + TERMINATOR: return True
		if comm == " CONDITION?" + TERMINATOR: return True
	return False
	
def ntransition_bool(comm, key):
	if key & 001:
		if comm == "NTR": return True
		if comm == "NTRANSITION": return True
		if comm == "NTR" + TERMINATOR: return True
		if comm == "NTRANSITION" + TERMINATOR: return True
		if comm == " NTR": return True
		if comm == " NTRANSITION": return True
		if comm == " NTR" + TERMINATOR: return True
		if comm == " NTRANSITION" + TERMINATOR: return True
	if key & 010:
		if comm == "NTR?": return True
		if comm == "NTRANSITION?": return True
		if comm == "NTR?" + TERMINATOR: return True
		if comm == "NTRANSITION?" + TERMINATOR: return True
		if comm == " NTR?": return True
		if comm == " NTRANSITION?": return True
		if comm == " NTR?" + TERMINATOR: return True
		if comm == " NTRANSITION?" + TERMINATOR: return True
	return False
	
def ptransition_bool(comm, key):
	if key & 001:
		if comm == "PTR": return True
		if comm == "PTRANSITION": return True
		if comm == "PTR" + TERMINATOR: return True
		if comm == "PTRANSITION" + TERMINATOR: return True
		if comm == " PTR": return True
		if comm == " PTRANSITION": return True
		if comm == " PTR" + TERMINATOR: return True
		if comm == " PTRANSITION" + TERMINATOR: return True
	if key & 010:
		if comm == "PTR?": return True
		if comm == "PTRANSITION?": return True
		if comm == "PTR?" + TERMINATOR: return True
		if comm == "PTRANSITION?" + TERMINATOR: return True
		if comm == " PTR?": return True
		if comm == " PTRANSITION?": return True
		if comm == " PTR?" + TERMINATOR: return True
		if comm == " PTRANSITION?" + TERMINATOR: return True
	return False
	
def temperature_bool(comm, key):
	if key & 001:
		if comm == "TEMP": return True
		if comm == "TEMPERATURE": return True
		if comm == "TEMP" + TERMINATOR: return True
		if comm == "TEMPERATURE" + TERMINATOR: return True
		if comm == " TEMP": return True
		if comm == " TEMPERATURE": return True
		if comm == " TEMP" + TERMINATOR: return True
		if comm == " TEMPERATURE" + TERMINATOR: return True
	if key & 010:
		if comm == "TEMP?": return True
		if comm == "TEMPERATURE?": return True
		if comm == "TEMP?" + TERMINATOR: return True
		if comm == "TEMPERATURE?" + TERMINATOR: return True
		if comm == " TEMP?": return True
		if comm == " TEMPERATURE?": return True
		if comm == " TEMP?" + TERMINATOR: return True
		if comm == " TEMPERATURE?" + TERMINATOR: return True
	return False

def shutdown_bool(comm, key):
	if key & 001:
		if comm == "SHUT": return True
		if comm == "SHUTDOWN": return True
		if comm == "SHUT" + TERMINATOR: return True
		if comm == "SHUTDOWN" + TERMINATOR: return True
		if comm == " SHUT": return True
		if comm == " SHUTDOWN": return True
		if comm == " SHUT" + TERMINATOR: return True
		if comm == " SHUTDOWN" + TERMINATOR: return True
	if key & 010:
		if comm == "SHUT?": return True
		if comm == "SHUTDOWN?": return True
		if comm == "SHUT?" + TERMINATOR: return True
		if comm == "SHUTDOWN?" + TERMINATOR: return True
		if comm == " SHUT?": return True
		if comm == " SHUTDOWN?": return True
		if comm == " SHUT?" + TERMINATOR: return True
		if comm == " SHUTDOWN?" + TERMINATOR: return True
	return False

def enable_bool(comm, key):
	if key & 001:
		if comm == "ENAB": return True
		if comm == "ENABLE": return True
		if comm == "ENAB" + TERMINATOR: return True
		if comm == "ENABLE" + TERMINATOR: return True
		if comm == " ENAB": return True
		if comm == " ENABLE": return True
		if comm == " ENAB" + TERMINATOR: return True
		if comm == " ENABLE" + TERMINATOR: return True
	if key & 010:
		if comm == "ENAB?": return True
		if comm == "ENABLE?": return True
		if comm == "ENAB?" + TERMINATOR: return True
		if comm == "ENABLE?" + TERMINATOR: return True
		if comm == " ENAB?": return True
		if comm == " ENABLE?": return True
		if comm == " ENAB?" + TERMINATOR: return True
		if comm == " ENABLE?" + TERMINATOR: return True
	return False

def event_bool(comm, key):
	if key & 001:
		if comm == "EVEN": return True
		if comm == "EVENT": return True
		if comm == "EVEN" + TERMINATOR: return True
		if comm == "EVENT" + TERMINATOR: return True
		if comm == " EVEN": return True
		if comm == " EVENT": return True
		if comm == " EVEN" + TERMINATOR: return True
		if comm == " EVENT" + TERMINATOR: return True
	if key & 010:
		if comm == "EVEN?": return True
		if comm == "EVENT?": return True
		if comm == "EVEN?" + TERMINATOR: return True
		if comm == "EVENT?" + TERMINATOR: return True
		if comm == " EVEN?": return True
		if comm == " EVENT?": return True
		if comm == " EVEN?" + TERMINATOR: return True
		if comm == " EVENT?" + TERMINATOR: return True
	return False

def preset_bool(comm, key):
	if key & 001:
		if comm == "PRES": return True
		if comm == "PRESET": return True
		if comm == "PRES" + TERMINATOR: return True
		if comm == "PRESET" + TERMINATOR: return True
		if comm == " PRES": return True
		if comm == " PRESET": return True
		if comm == " PRES" + TERMINATOR: return True
		if comm == " PRESET" + TERMINATOR: return True
	if key & 010:
		if comm == "PRES?": return True
		if comm == "PRESET?": return True
		if comm == "PRES?" + TERMINATOR: return True
		if comm == "PRESET?" + TERMINATOR: return True
		if comm == " PRES?": return True
		if comm == " PRESET?": return True
		if comm == " PRES?" + TERMINATOR: return True
		if comm == " PRESET?" + TERMINATOR: return True
	return False
	
def standard_bool(comm, key):
	if key & 001:
		if comm == "STAN": return True
		if comm == "STANDARD": return True
		if comm == "STAN" + TERMINATOR: return True
		if comm == "STANDARD" + TERMINATOR: return True
		if comm == " STAN": return True
		if comm == " STANDARD": return True
		if comm == " STAN" + TERMINATOR: return True
		if comm == " STANDARD" + TERMINATOR: return True
	if key & 010:
		if comm == "STAN?": return True
		if comm == "STANDARD?": return True
		if comm == "STAN?" + TERMINATOR: return True
		if comm == "STANDARD?" + TERMINATOR: return True
		if comm == " STAN?": return True
		if comm == " STANDARD?": return True
		if comm == " STAN?" + TERMINATOR: return True
		if comm == " STANDARD?" + TERMINATOR: return True
	return False
	
def sbyte_bool(comm, key):
	if key & 001:
		if comm == "SBYT": return True
		if comm == "SBYTE": return True
		if comm == "SBYT" + TERMINATOR: return True
		if comm == "SBYTE" + TERMINATOR: return True
		if comm == " SBYT": return True
		if comm == " SBYTE": return True
		if comm == " SBYT" + TERMINATOR: return True
		if comm == " SBYTE" + TERMINATOR: return True
	if key & 010:
		if comm == "SBYT?": return True
		if comm == "SBYTE?": return True
		if comm == "SBYT?" + TERMINATOR: return True
		if comm == "SBYTE?" + TERMINATOR: return True
		if comm == " SBYT?": return True
		if comm == " SBYTE?": return True
		if comm == " SBYT?" + TERMINATOR: return True
		if comm == " SBYTE?" + TERMINATOR: return True
	return False
	
def srequest_bool(comm, key):
	if key & 001:
		if comm == "SREQ": return True
		if comm == "SREQUEST": return True
		if comm == "SREQ" + TERMINATOR: return True
		if comm == "SREQUEST" + TERMINATOR: return True
		if comm == " SREQ": return True
		if comm == " SREQUEST": return True
		if comm == " SREQ" + TERMINATOR: return True
		if comm == " SREQUEST" + TERMINATOR: return True
	if key & 010:
		if comm == "SREQ?": return True
		if comm == "SREQUEST?": return True
		if comm == "SREQ?" + TERMINATOR: return True
		if comm == "SREQUEST?" + TERMINATOR: return True
		if comm == " SREQ?": return True
		if comm == " SREQUEST?": return True
		if comm == " SREQ?" + TERMINATOR: return True
		if comm == " SREQUEST?" + TERMINATOR: return True
	return False

def questionable_bool(comm, key):
	if key & 001:
		if comm == "QUES": return True
		if comm == "QUESTIONABLE": return True
		if comm == "QUES" + TERMINATOR: return True
		if comm == "QUESTIONABLE" + TERMINATOR: return True
		if comm == " QUES": return True
		if comm == " QUESTIONABLE": return True
		if comm == " QUES" + TERMINATOR: return True
		if comm == " QUESTIONABLE" + TERMINATOR: return True
	if key & 010:
		if comm == "QUES?": return True
		if comm == "QUESTIONABLE?": return True
		if comm == "QUES?" + TERMINATOR: return True
		if comm == "QUESTIONABLE?" + TERMINATOR: return True
		if comm == " QUES?": return True
		if comm == " QUESTIONABLE?": return True
		if comm == " QUES?" + TERMINATOR: return True
		if comm == " QUESTIONABLE?" + TERMINATOR: return True
	return False

def system_bool(comm, key):
	if key & 001:
		if comm == "SYST": return True
		if comm == "SYSTEM": return True
		if comm == "SYST" + TERMINATOR: return True
		if comm == "SYSTEM" + TERMINATOR: return True
		if comm == " SYST": return True
		if comm == " SYSTEM": return True
		if comm == " SYST" + TERMINATOR: return True
		if comm == " SYSTEM" + TERMINATOR: return True
	if key & 010:
		if comm == "SYST?": return True
		if comm == "SYSTEM?": return True
		if comm == "SYST?" + TERMINATOR: return True
		if comm == "SYSTEM?" + TERMINATOR: return True
		if comm == " SYST?": return True
		if comm == " SYSTEM?": return True
		if comm == " SYST?" + TERMINATOR: return True
		if comm == " SYSTEM?" + TERMINATOR: return True
	return False
	
def fpanel_bool(comm, key):
	if key & 001:
		if comm == "FPAN": return True
		if comm == "FPANEL": return True
		if comm == "FPAN" + TERMINATOR: return True
		if comm == "FPANEL" + TERMINATOR: return True
		if comm == " FPAN": return True
		if comm == " FPANEL": return True
		if comm == " FPAN" + TERMINATOR: return True
		if comm == " FPANEL" + TERMINATOR: return True
	if key & 010:
		if comm == "FPAN?": return True
		if comm == "FPANEL?": return True
		if comm == "FPAN?" + TERMINATOR: return True
		if comm == "FPANEL?" + TERMINATOR: return True
		if comm == " FPAN?": return True
		if comm == " FPANEL?": return True
		if comm == " FPAN?" + TERMINATOR: return True
		if comm == " FPANEL?" + TERMINATOR: return True
	return False

def error_bool(comm, key):
	if key & 001:
		if comm == "ERR": return True
		if comm == "ERROR": return True
		if comm == "ERR" + TERMINATOR: return True
		if comm == "ERROR" + TERMINATOR: return True
		if comm == " ERR": return True
		if comm == " ERROR": return True
		if comm == " ERR" + TERMINATOR: return True
		if comm == " ERROR" + TERMINATOR: return True
	if key & 010:
		if comm == "ERR?": return True
		if comm == "ERROR?": return True
		if comm == "ERR?" + TERMINATOR: return True
		if comm == "ERROR?" + TERMINATOR: return True
		if comm == " ERR?": return True
		if comm == " ERROR?": return True
		if comm == " ERR?" + TERMINATOR: return True
		if comm == " ERROR?" + TERMINATOR: return True
	return False
	
def next_bool(comm, key):
	if key & 001:
		if comm == "NEXT": return True
		if comm == "NEXT" + TERMINATOR: return True
		if comm == " NEXT": return True
		if comm == " NEXT" + TERMINATOR: return True
	if key & 010:
		if comm == "NEXT?": return True
		if comm == "NEXT?" + TERMINATOR: return True
		if comm == " NEXT?": return True
		if comm == " NEXT?" + TERMINATOR: return True
	return False
	
def code_bool(comm, key):
	if key & 001:
		if comm == "CODE": return True
		if comm == "CODE" + TERMINATOR: return True
		if comm == " CODE": return True
		if comm == " CODE" + TERMINATOR: return True
	if key & 010:
		if comm == "CODE?": return True
		if comm == "CODE?" + TERMINATOR: return True
		if comm == " CODE?": return True
		if comm == " CODE?" + TERMINATOR: return True
	return False

def count_bool(comm, key):
	if key & 001:
		if comm == "COUN": return True
		if comm == "COUNT": return True
		if comm == "COUN" + TERMINATOR: return True
		if comm == "COUNT" + TERMINATOR: return True
		if comm == " COUN": return True
		if comm == " COUNT": return True
		if comm == " COUN" + TERMINATOR: return True
		if comm == " COUNT" + TERMINATOR: return True
	if key & 010:
		if comm == "COUN?": return True
		if comm == "COUNT?": return True
		if comm == "COUN?" + TERMINATOR: return True
		if comm == "COUNT?" + TERMINATOR: return True
		if comm == " COUN?": return True
		if comm == " COUNT?": return True
		if comm == " COUN?" + TERMINATOR: return True
		if comm == " COUNT?" + TERMINATOR: return True
	return False
	
def communicate_bool(comm, key):
	if key & 001:
		if comm == "COMM": return True
		if comm == "COMMUNICATE": return True
		if comm == "COMM" + TERMINATOR: return True
		if comm == "COMMUNICATE" + TERMINATOR: return True
		if comm == " COMM": return True
		if comm == " COMMUNICATE": return True
		if comm == " COMM" + TERMINATOR: return True
		if comm == " COMMUNICATE" + TERMINATOR: return True
	if key & 010:
		if comm == "COMM?": return True
		if comm == "COMMUNICATE?": return True
		if comm == "COMM?" + TERMINATOR: return True
		if comm == "COMMUNICATE?" + TERMINATOR: return True
		if comm == " COMM?": return True
		if comm == " COMMUNICATE?": return True
		if comm == " COMM?" + TERMINATOR: return True
		if comm == " COMMUNICATE?" + TERMINATOR: return True
	return False

def remote_bool(comm, key):
	if key & 001:
		if comm == "REM": return True
		if comm == "REMOTE": return True
		if comm == "REM" + TERMINATOR: return True
		if comm == "REMOTE" + TERMINATOR: return True
		if comm == " REM": return True
		if comm == " REMOTE": return True
		if comm == " REM" + TERMINATOR: return True
		if comm == " REMOTE" + TERMINATOR: return True
	if key & 010:
		if comm == "REM?": return True
		if comm == "REMOTE?": return True
		if comm == "REM?" + TERMINATOR: return True
		if comm == "REMOTE?" + TERMINATOR: return True
		if comm == " REM?": return True
		if comm == " REMOTE?": return True
		if comm == " REM?" + TERMINATOR: return True
		if comm == " REMOTE?" + TERMINATOR: return True
	return False

def local_bool(comm, key):
	if key & 001:
		if comm == "LOC": return True
		if comm == "LOCAL": return True
		if comm == "LOC" + TERMINATOR: return True
		if comm == "LOCAL" + TERMINATOR: return True
		if comm == " LOC": return True
		if comm == " LOCAL": return True
		if comm == " LOC" + TERMINATOR: return True
		if comm == " LOCAL" + TERMINATOR: return True
	if key & 010:
		if comm == "LOC?": return True
		if comm == "LOCAL?": return True
		if comm == "LOC?" + TERMINATOR: return True
		if comm == "LOCAL?" + TERMINATOR: return True
		if comm == " LOC?": return True
		if comm == " LOCAL?": return True
		if comm == " LOC?" + TERMINATOR: return True
		if comm == " LOCAL?" + TERMINATOR: return True
	return False
	
def avoltage_bool(comm, key):
	if key & 001:
		if comm == "AVOL": return True
		if comm == "AVOLTAGE": return True
		if comm == "AVOL" + TERMINATOR: return True
		if comm == "AVOLTAGE" + TERMINATOR: return True
		if comm == " AVOL": return True
		if comm == " AVOLTAGE": return True
		if comm == " AVOL" + TERMINATOR: return True
		if comm == " AVOLTAGE" + TERMINATOR: return True
	if key & 010:
		if comm == "AVOL?": return True
		if comm == "AVOLTAGE?": return True
		if comm == "AVOL?" + TERMINATOR: return True
		if comm == "AVOLTAGE?" + TERMINATOR: return True
		if comm == " AVOL?": return True
		if comm == " AVOLTAGE?": return True
		if comm == " AVOL?" + TERMINATOR: return True
		if comm == " AVOLTAGE?" + TERMINATOR: return True
	return False

def iavoltage_bool(comm, key):
	if key & 001:
		if comm == "IAV": return True
		if comm == "IAVOLTAGE": return True
		if comm == "IAV" + TERMINATOR: return True
		if comm == "IAVOLTAGE" + TERMINATOR: return True
		if comm == " IAV": return True
		if comm == " IAVOLTAGE": return True
		if comm == " IAV" + TERMINATOR: return True
		if comm == " IAVOLTAGE" + TERMINATOR: return True
	if key & 010:
		if comm == "IAV?": return True
		if comm == "IAVOLTAGE?": return True
		if comm == "IAV?" + TERMINATOR: return True
		if comm == "IAVOLTAGE?" + TERMINATOR: return True
		if comm == " IAV?": return True
		if comm == " IAVOLTAGE?": return True
		if comm == " IAV?" + TERMINATOR: return True
		if comm == " IAVOLTAGE?" + TERMINATOR: return True
	return False

def aresistive_bool(comm, key):
	if key & 001:
		if comm == "ARES": return True
		if comm == "ARESISTIVE": return True
		if comm == "ARES" + TERMINATOR: return True
		if comm == "ARESISTIVE" + TERMINATOR: return True
		if comm == " ARES": return True
		if comm == " ARESISTIVE": return True
		if comm == " ARES" + TERMINATOR: return True
		if comm == " ARESISTIVE" + TERMINATOR: return True
	if key & 010:
		if comm == "ARES?": return True
		if comm == "ARESISTIVE?": return True
		if comm == "ARES?" + TERMINATOR: return True
		if comm == "ARESISTIVE?" + TERMINATOR: return True
		if comm == " ARES?": return True
		if comm == " ARESISTIVE?": return True
		if comm == " ARES?" + TERMINATOR: return True
		if comm == " ARESISTIVE?" + TERMINATOR: return True
	return False

def iaresistive_bool(comm, key):
	if key & 001:
		if comm == "IAR": return True
		if comm == "IARESISTIVE": return True
		if comm == "IAR" + TERMINATOR: return True
		if comm == "IARESISTIVE" + TERMINATOR: return True
		if comm == " IAR": return True
		if comm == " IARESISTIVE": return True
		if comm == " IAR" + TERMINATOR: return True
		if comm == " IARESISTIVE" + TERMINATOR: return True
	if key & 010:
		if comm == "IAR?": return True
		if comm == "IARESISTIVE?": return True
		if comm == "IAR?" + TERMINATOR: return True
		if comm == "IARESISTIVE?" + TERMINATOR: return True
		if comm == " IAR?": return True
		if comm == " IARESISTIVE?": return True
		if comm == " IAR?" + TERMINATOR: return True
		if comm == " IARESISTIVE?" + TERMINATOR: return True
	return False

def mask_bool(comm, key):
	if key & 001:
		if comm == "MASK": return True
		if comm == "MASK" + TERMINATOR: return True
		if comm == " MASK": return True
		if comm == " MASK" + TERMINATOR: return True
	if key & 010:
		if comm == "MASK?": return True
		if comm == "MASK?" + TERMINATOR: return True
		if comm == " MASK?": return True
		if comm == " MASK?" + TERMINATOR: return True
	return False

def latch_bool(comm, key):
	if key & 001:
		if comm == "LATC": return True
		if comm == "LATCH": return True
		if comm == "LATC" + TERMINATOR: return True
		if comm == "LATCH" + TERMINATOR: return True
		if comm == " LATC": return True
		if comm == " LATCH": return True
		if comm == " LATC" + TERMINATOR: return True
		if comm == " LATCH" + TERMINATOR: return True
	if key & 010:
		if comm == "LATC?": return True
		if comm == "LATCH?": return True
		if comm == "LATC?" + TERMINATOR: return True
		if comm == "LATCH?" + TERMINATOR: return True
		if comm == " LATC?": return True
		if comm == " LATCH?": return True
		if comm == " LATC?" + TERMINATOR: return True
		if comm == " LATCH?" + TERMINATOR: return True
	return False

def version_bool(comm, key):
	if key & 001:
		if comm == "VERS": return True
		if comm == "VERSION": return True
		if comm == "VERS" + TERMINATOR: return True
		if comm == "VERSION" + TERMINATOR: return True
		if comm == " VERS": return True
		if comm == " VERSION": return True
		if comm == " VERS" + TERMINATOR: return True
		if comm == " VERSION" + TERMINATOR: return True
	if key & 010:
		if comm == "VERS?": return True
		if comm == "VERSION?": return True
		if comm == "VERS?" + TERMINATOR: return True
		if comm == "VERSION?" + TERMINATOR: return True
		if comm == " VERS?": return True
		if comm == " VERSION?": return True
		if comm == " VERS?" + TERMINATOR: return True
		if comm == " VERSION?" + TERMINATOR: return True
	return False
	
def help_bool(comm, key):
	if key & 001:
		if comm == "HELP": return True
		if comm == "HELP" + TERMINATOR: return True
		if comm == " HELP": return True
		if comm == " HELP" + TERMINATOR: return True
	if key & 010:
		if comm == "HELP?": return True
		if comm == "HELP?" + TERMINATOR: return True
		if comm == " HELP?": return True
		if comm == " HELP?" + TERMINATOR: return True
	return False

def headers_bool(comm, key):
	if key & 001:
		if comm == "HEAD": return True
		if comm == "HEADERS": return True
		if comm == "HEAD" + TERMINATOR: return True
		if comm == "HEADERS" + TERMINATOR: return True
		if comm == " HEAD": return True
		if comm == " HEADERS": return True
		if comm == " HEAD" + TERMINATOR: return True
		if comm == " HEADERS" + TERMINATOR: return True
	if key & 010:
		if comm == "HEAD?": return True
		if comm == "HEADERS?": return True
		if comm == "HEAD?" + TERMINATOR: return True
		if comm == "HEADERS?" + TERMINATOR: return True
		if comm == " HEAD?": return True
		if comm == " HEADERS?": return True
		if comm == " HEAD?" + TERMINATOR: return True
		if comm == " HEADERS?" + TERMINATOR: return True
	return False
	
def legacy_bool(comm, key):
	if key & 001:
		if comm == "LEG": return True
		if comm == "LEGACY": return True
		if comm == "LEG" + TERMINATOR: return True
		if comm == "LEGACY" + TERMINATOR: return True
		if comm == " LEG": return True
		if comm == " LEGACY": return True
		if comm == " LEG" + TERMINATOR: return True
		if comm == " LEGACY" + TERMINATOR: return True
	if key & 010:
		if comm == "LEG?": return True
		if comm == "LEGACY?": return True
		if comm == "LEG?" + TERMINATOR: return True
		if comm == "LEGACY?" + TERMINATOR: return True
		if comm == " LEG?": return True
		if comm == " LEGACY?": return True
		if comm == " LEG?" + TERMINATOR: return True
		if comm == " LEGACY?" + TERMINATOR: return True
	return False
	
def calibration_bool(comm, key):
	if key & 001:
		if comm == "CAL": return True
		if comm == "CALIBRATION": return True
		if comm == "CAL" + TERMINATOR: return True
		if comm == "CALIBRATION" + TERMINATOR: return True
		if comm == " CAL": return True
		if comm == " CALIBRATION": return True
		if comm == " CAL" + TERMINATOR: return True
		if comm == " CALIBRATION" + TERMINATOR: return True
	if key & 010:
		if comm == "CAL?": return True
		if comm == "CALIBRATION?": return True
		if comm == "CAL?" + TERMINATOR: return True
		if comm == "CALIBRATION?" + TERMINATOR: return True
		if comm == " CAL?": return True
		if comm == " CALIBRATION?": return True
		if comm == " CAL?" + TERMINATOR: return True
		if comm == " CALIBRATION?" + TERMINATOR: return True
	return False

def poweron_bool(comm, key):
	if key & 001:
		if comm == "PON": return True
		if comm == "POWERON": return True
		if comm == "PON" + TERMINATOR: return True
		if comm == "POWERON" + TERMINATOR: return True
		if comm == " PON": return True
		if comm == " POWERON": return True
		if comm == " PON" + TERMINATOR: return True
		if comm == " POWERON" + TERMINATOR: return True
	if key & 010:
		if comm == "POWERON?": return True
		if comm == "PON?": return True
		if comm == "POWERON?" + TERMINATOR: return True
		if comm == "PON?" + TERMINATOR: return True
		if comm == " POWERON?": return True
		if comm == " PON?": return True
		if comm == " POWERON?" + TERMINATOR: return True
		if comm == " PON?" + TERMINATOR: return True
	return False

def reset_bool(comm, key):
	if key & 001:
		if comm == "RES": return True
		if comm == "RESET": return True
		if comm == "RES" + TERMINATOR: return True
		if comm == "RESET" + TERMINATOR: return True
		if comm == " RES": return True
		if comm == " RESET": return True
		if comm == " RES" + TERMINATOR: return True
		if comm == " RESET" + TERMINATOR: return True
	if key & 010:
		if comm == "RES?": return True
		if comm == "RESET?": return True
		if comm == "RES?" + TERMINATOR: return True
		if comm == "RESET?" + TERMINATOR: return True
		if comm == " RES?": return True
		if comm == " RESET?": return True
		if comm == " RES?" + TERMINATOR: return True
		if comm == " RESET?" + TERMINATOR: return True
	return False
	
def wait_bool(comm, key):
	if key & 001:
		if comm == "WAIT": return True
		if comm == "WAIT" + TERMINATOR: return True
		if comm == " WAIT": return True
		if comm == " WAIT" + TERMINATOR: return True
	if key & 010:
		if comm == "WAIT?": return True
		if comm == "WAIT?" + TERMINATOR: return True
		if comm == " WAIT?": return True
		if comm == " WAIT?" + TERMINATOR: return True
	return False


def test_bool(comm, key):
	if key & 001:
		if comm == "TEST": return True
		if comm == "TEST" + TERMINATOR: return True
		if comm == " TEST": return True
		if comm == " TEST" + TERMINATOR: return True
	if key & 010:
		if comm == "TEST?": return True
		if comm == "TEST?" + TERMINATOR: return True
		if comm == " TEST?": return True
		if comm == " TEST?" + TERMINATOR: return True
	return False


def identify_bool(comm, key):
	if key & 001:
		if comm == "IDEN": return True
		if comm == "IDENTIFY": return True
		if comm == "IDEN" + TERMINATOR: return True
		if comm == "IDENTIFY" + TERMINATOR: return True
		if comm == " IDEN": return True
		if comm == " IDENTIFY": return True
		if comm == " IDEN" + TERMINATOR: return True
		if comm == " IDENTIFY" + TERMINATOR: return True
	if key & 010:
		if comm == "IDEN?": return True
		if comm == "IDENTIFY?": return True
		if comm == "IDEN?" + TERMINATOR: return True
		if comm == "IDENTIFY?" + TERMINATOR: return True
		if comm == " IDEN?": return True
		if comm == " IDENTIFY?": return True
		if comm == " IDEN?" + TERMINATOR: return True
		if comm == " IDENTIFY?" + TERMINATOR: return True
	return False
	

def save_bool(comm, key):
	if key & 001:
		if comm == "SAVE": return True
		if comm == "SAVE" + TERMINATOR: return True
		if comm == " SAVE": return True
		if comm == " SAVE" + TERMINATOR: return True
	if key & 010:
		if comm == "SAVE?": return True
		if comm == "SAVE?" + TERMINATOR: return True
		if comm == " SAVE?": return True
		if comm == " SAVE?" + TERMINATOR: return True
	return False


def recall_bool(comm, key):
	if key & 001:
		if comm == "REC": return True
		if comm == "RECALL": return True
		if comm == "REC" + TERMINATOR: return True
		if comm == "RECALL" + TERMINATOR: return True
		if comm == " REC": return True
		if comm == " RECALL": return True
		if comm == " REC" + TERMINATOR: return True
		if comm == " RECALL" + TERMINATOR: return True
	if key & 010:
		if comm == "REC?": return True
		if comm == "RECALL?": return True
		if comm == "REC?" + TERMINATOR: return True
		if comm == "RECALL?" + TERMINATOR: return True
		if comm == " REC?": return True
		if comm == " RECALL?": return True
		if comm == " REC?" + TERMINATOR: return True
		if comm == " RECALL?" + TERMINATOR: return True
	return False


def restore_bool(comm, key):
	if key & 001:
		if comm == "REST": return True
		if comm == "RESTORE": return True
		if comm == "REST" + TERMINATOR: return True
		if comm == "RESTORE" + TERMINATOR: return True
		if comm == " REST": return True
		if comm == " RESTORE": return True
		if comm == " REST" + TERMINATOR: return True
		if comm == " RESTORE" + TERMINATOR: return True
	if key & 010:
		if comm == "REST?": return True
		if comm == "RESTORE?": return True
		if comm == "REST?" + TERMINATOR: return True
		if comm == "RESTORE?" + TERMINATOR: return True
		if comm == " REST?": return True
		if comm == " RESTORE?": return True
		if comm == " REST?" + TERMINATOR: return True
		if comm == " RESTORE?" + TERMINATOR: return True
	return False

def store_bool(comm, key):
	if key & 001:
		if comm == "STOR": return True
		if comm == "STORE": return True
		if comm == "STOR" + TERMINATOR: return True
		if comm == "STORE" + TERMINATOR: return True
		if comm == " STOR": return True
		if comm == " STORE": return True
		if comm == " STOR" + TERMINATOR: return True
		if comm == " STORE" + TERMINATOR: return True
	if key & 010:
		if comm == "STOR?": return True
		if comm == "STORE?": return True
		if comm == "STOR?" + TERMINATOR: return True
		if comm == "STORE?" + TERMINATOR: return True
		if comm == " STOR?": return True
		if comm == " STORE?": return True
		if comm == " STOR?" + TERMINATOR: return True
		if comm == " STORE?" + TERMINATOR: return True
	return False

def initiate_bool(comm, key):
	if key & 001:
		if comm == "INIT": return True
		if comm == "INITIATE": return True
		if comm == "INIT" + TERMINATOR: return True
		if comm == "INITIATE" + TERMINATOR: return True
		if comm == " INIT": return True
		if comm == " INITIATE": return True
		if comm == " INIT" + TERMINATOR: return True
		if comm == " INITIATE" + TERMINATOR: return True
	if key & 010:
		if comm == "INIT?": return True
		if comm == "INITIATE?": return True
		if comm == "INIT?" + TERMINATOR: return True
		if comm == "INITIATE?" + TERMINATOR: return True
		if comm == " INIT?": return True
		if comm == " INITIATE?": return True
		if comm == " INIT?" + TERMINATOR: return True
		if comm == " INITIATE?" + TERMINATOR: return True
	return False

def immediate_bool(comm, key):
	if key & 001:
		if comm == "IMM": return True
		if comm == "IMMEDIATE": return True
		if comm == "IMM" + TERMINATOR: return True
		if comm == "IMMEDIATE" + TERMINATOR: return True
		if comm == " IMM": return True
		if comm == " IMMEDIATE": return True
		if comm == " IMM" + TERMINATOR: return True
		if comm == " IMMEDIATE" + TERMINATOR: return True
	if key & 010:
		if comm == "IMM?": return True
		if comm == "IMMEDIATE?": return True
		if comm == "IMM?" + TERMINATOR: return True
		if comm == "IMMEDIATE?" + TERMINATOR: return True
		if comm == " IMM?": return True
		if comm == " IMMEDIATE?": return True
		if comm == " IMM?" + TERMINATOR: return True
		if comm == " IMMEDIATE?" + TERMINATOR: return True
	return False

def interlock_bool(comm, key):
	if key & 001:
		if comm == "INT": return True
		if comm == "INTERLOCK": return True
		if comm == "INT" + TERMINATOR: return True
		if comm == "INTERLOCK" + TERMINATOR: return True
		if comm == " INT": return True
		if comm == " INTERLOCK": return True
		if comm == " INT" + TERMINATOR: return True
		if comm == " INTERLOCK" + TERMINATOR: return True
	if key & 010:
		if comm == "INT?": return True
		if comm == "INTERLOCK?": return True
		if comm == "INT?" + TERMINATOR: return True
		if comm == "INTERLOCK?" + TERMINATOR: return True
		if comm == " INT?": return True
		if comm == " INTERLOCK?": return True
		if comm == " INT?" + TERMINATOR: return True
		if comm == " INTERLOCK?" + TERMINATOR: return True
	return False

def program_bool(comm, key):
	if key & 001:
		if comm == "PROG": return True
		if comm == "PROGRAM": return True
		if comm == "PROG" + TERMINATOR: return True
		if comm == "PROGRAM" + TERMINATOR: return True
		if comm == " PROG": return True
		if comm == " PROGRAM": return True
		if comm == " PROG" + TERMINATOR: return True
		if comm == " PROGRAM" + TERMINATOR: return True
	if key & 010:
		if comm == "PROG?": return True
		if comm == "PROGRAM?": return True
		if comm == "PROG?" + TERMINATOR: return True
		if comm == "PROGRAM?" + TERMINATOR: return True
		if comm == " PROG?": return True
		if comm == " PROGRAM?": return True
		if comm == " PROG?" + TERMINATOR: return True
		if comm == " PROGRAM?" + TERMINATOR: return True
	return False

def delete_bool(comm, key):
	if key & 001:
		if comm == "DEL": return True
		if comm == "DELETE": return True
		if comm == "DEL" + TERMINATOR: return True
		if comm == "DELETE" + TERMINATOR: return True
		if comm == " DEL": return True
		if comm == " DELETE": return True
		if comm == " DEL" + TERMINATOR: return True
		if comm == " DELETE" + TERMINATOR: return True
	if key & 010:
		if comm == "DEL?": return True
		if comm == "DELETE?": return True
		if comm == "DEL?" + TERMINATOR: return True
		if comm == "DELETE?" + TERMINATOR: return True
		if comm == " DEL?": return True
		if comm == " DELETE?": return True
		if comm == " DEL?" + TERMINATOR: return True
		if comm == " DELETE?" + TERMINATOR: return True
	return False

def repeat_bool(comm, key):
	if key & 001:
		if comm == "REP": return True
		if comm == "REPEAT": return True
		if comm == "REP" + TERMINATOR: return True
		if comm == "REPEAT" + TERMINATOR: return True
		if comm == " REP": return True
		if comm == " REPEAT": return True
		if comm == " REP" + TERMINATOR: return True
		if comm == " REPEAT" + TERMINATOR: return True
	if key & 010:
		if comm == "REP?": return True
		if comm == "REPEAT?": return True
		if comm == "REP?" + TERMINATOR: return True
		if comm == "REPEAT?" + TERMINATOR: return True
		if comm == " REP?": return True
		if comm == " REPEAT?": return True
		if comm == " REP?" + TERMINATOR: return True
		if comm == " REPEAT?" + TERMINATOR: return True
	return False

def record_bool(comm, key):
	if key & 001:
		if comm == "REC": return True
		if comm == "RECORD": return True
		if comm == "REC" + TERMINATOR: return True
		if comm == "RECORD" + TERMINATOR: return True
		if comm == " REC": return True
		if comm == " RECORD": return True
		if comm == " REC" + TERMINATOR: return True
		if comm == " RECORD" + TERMINATOR: return True
	if key & 010:
		if comm == "REC?": return True
		if comm == "RECORD?": return True
		if comm == "REC?" + TERMINATOR: return True
		if comm == "RECORD?" + TERMINATOR: return True
		if comm == " REC?": return True
		if comm == " RECORD?": return True
		if comm == " REC?" + TERMINATOR: return True
		if comm == " RECORD?" + TERMINATOR: return True
	return False

def start_bool(comm, key):
	if key & 001:
		if comm == "STAR": return True
		if comm == "START": return True
		if comm == "STAR" + TERMINATOR: return True
		if comm == "START" + TERMINATOR: return True
		if comm == " STAR": return True
		if comm == " START": return True
		if comm == " STAR" + TERMINATOR: return True
		if comm == " START" + TERMINATOR: return True
	if key & 010:
		if comm == "STAR?": return True
		if comm == "START?": return True
		if comm == "STAR?" + TERMINATOR: return True
		if comm == "START?" + TERMINATOR: return True
		if comm == " STAR?": return True
		if comm == " START?": return True
		if comm == " STAR?" + TERMINATOR: return True
		if comm == " START?" + TERMINATOR: return True
	return False

def stop_bool(comm, key):
	if key & 001:
		if comm == "STOP": return True
		if comm == "STOP" + TERMINATOR: return True
		if comm == " STOP": return True
		if comm == " STOP" + TERMINATOR: return True
	if key & 010:
		if comm == "STOP?": return True
		if comm == "STOP?" + TERMINATOR: return True
		if comm == " STOP?": return True
		if comm == " STOP?" + TERMINATOR: return True
	return False

def step_bool(comm, key):
	if key & 001:
		if comm == "STEP": return True
		if comm == "STEP" + TERMINATOR: return True
		if comm == " STEP": return True
		if comm == " STEP" + TERMINATOR: return True
	if key & 010:
		if comm == "STEP?": return True
		if comm == "STEP?" + TERMINATOR: return True
		if comm == " STEP?": return True
		if comm == " STEP?" + TERMINATOR: return True
	return False

def dwel1_bool(comm, key):
	if key & 001:
		if comm == "DWEL1": return True
		if comm == "DWEL1" + TERMINATOR: return True
		if comm == " DWEL1": return True
		if comm == " DWEL1" + TERMINATOR: return True
	if key & 010:
		if comm == "DWEL1?": return True
		if comm == "DWEL1?" + TERMINATOR: return True
		if comm == " DWEL1?": return True
		if comm == " DWEL1?" + TERMINATOR: return True
	return False

def readback_bool(comm, key):
	if key & 001:
		if comm == "READ": return True
		if comm == "READBACK": return True
		if comm == "READ" + TERMINATOR: return True
		if comm == "READBACK" + TERMINATOR: return True
		if comm == " READ": return True
		if comm == " READBACK": return True
		if comm == " READ" + TERMINATOR: return True
		if comm == " READBACK" + TERMINATOR: return True
	if key & 010:
		if comm == "READ?": return True
		if comm == "READBACK?": return True
		if comm == "READ?" + TERMINATOR: return True
		if comm == "READBACK?" + TERMINATOR: return True
		if comm == " READ?": return True
		if comm == " READBACK?": return True
		if comm == " READ?" + TERMINATOR: return True
		if comm == " READBACK?" + TERMINATOR: return True
	return False




####################################################################################################
# Functions for error messages
####################################################################################################

#Check if overflow and which element is 0
def err_element(i):
	#Check if there is any error states with 0
	for index in xrange(1, 11):
		if ERR[i][index-1] == 0:
			return index

	#Check if there is any error state with -350
	for index in xrange(9, 0, -1):
		if ERR[i][index] == -350:
			if ERR[i][index-1] != -350:
				ERR[i][index-1] = -350
				print(ERR[i])
				return False

	#All states where occupied
	ERR[i][9] = -350
	print(ERR[i])
	return False

#Find small description corresponding to displayed error
def err_description(error):
	print("Entered fcn that gives small description to the error")

	if error == 0:
		return " No error"
	elif error == -102:
		return " Syntax error"
	elif error == -108:
		return " Parameter not allowed"
	elif error == -151:
		return " Invalid string data"
	elif error == -161:
		return " Invalid block data"
	elif error == -203:
		return " Command protected"
	elif error == -221:
		return " Settings conflict"
	elif error == -222:
		return " Data out of range"
	elif error == -350:
		return " Queue overflow"

#Error if unrecognized command or data type was encountered
def err_syntax_error(ch):
	global ERR
	print("Entered err syntax error")

	for i in ch:
		if err_element(i):	#If there is a free slot
			ERR[i][err_element(i)-1] = -102	#... save the error at that slot
			set_status_byte_register(i)
			set_standard_event_register(i)
			print(ERR[i])

def err_wrong_number_of_parameters(par_given, par_expected, ch):
	if par_given < par_expected:
		err_missing_parameter(ch)
	else:
		err_parameter_not_allowed(ch)

#Error if more arguments than expected were received
def err_parameter_not_allowed(ch):
	global ERR
	print("Entered err parameter not allowed")

	for i in ch:
		if err_element(i):	#If there is a free slot
			ERR[i][err_element(i)-1] = -108	#... save the error at that slot
			set_status_byte_register(i)
			set_standard_event_register(i)
			print(ERR[i])
			
#Error if fewer arguments than expected were received
def err_missing_parameter(ch):
	global ERR
	print("Entered err err_missing parameter")

	for i in ch:
		if err_element(i):	#If there is a free slot
			ERR[i][err_element(i)-1] = -109	#... save the error at that slot
			set_status_byte_register(i)
			set_standard_event_register(i)
			print(ERR[i])

#Error if incorrect password. Manufacurer, model, or serial number string was more than 16 characters. Invalid mnemonic.
def err_invalid_string_data(ch):
	global ERR
	print("Entered err invalid string data")

	for i in ch:
		if err_element(i):	#If there is a free slot
			ERR[i][err_element(i)-1] = -151	#... save the error at that slot
			set_status_byte_register(i)
			set_standard_event_register(i)
			print(ERR[i])

#Error if the expected number of data values was not received
def err_invalid_block_data(ch):
	global ERR
	print("Entered err invalid block data")

	for i in ch:
		if err_element(i):	#If there is a free slot
			ERR[i][err_element(i)-1] = -161	#... save the error at that slot
			set_status_byte_register(i)
			set_standard_event_register(i)
			print(ERR[i])

#Error if attempting to store calibration values without unlocking
def err_command_protected(ch):
	global ERR
	print("Entered err command protected")

	for i in ch:
		if err_element(i):	#If there is a free slot
			ERR[i][err_element(i)-1] = -203	#... save the error at that slot
			set_status_byte_register(i)
			set_standard_event_register(i)
			print(ERR[i])

#Error if output greater than soft limit or soft limit less than output
def err_settings_conflict(ch):
	global ERR
	print("Entered err settings conflict")

	for i in ch:
		if err_element(i):	#If there is a free slot
			ERR[i][err_element(i)-1] = -221	#... save the error at that slot
			set_status_byte_register(i)
			set_standard_event_register(i)
			print(ERR[i])

#Error if parameter exceeded range of valid values
def err_data_out_of_range(ch):
	global ERR
	print("Entered err data out of range")

	for i in ch:
		if err_element(i):	#If there is a free slot
			ERR[i][err_element(i)-1] = -222	#... save the error at that slot
			set_status_byte_register(i)
			set_standard_event_register(i)
			print(ERR[i])
			
			
			
####################################################################################################
# Fcns for setting bits in registers
####################################################################################################

#Status Byte register
def set_status_byte_register(i):
	global status_byte_register
	
	if ERR[i] != ([0] * 10):
		status_byte_register[i] = status_byte_register[i] | 0b00000100
	if questionable_event_register[i] & questionable_enable_register[i]:
		status_byte_register[i] = status_byte_register[i] | 0b00001000
	if standard_event_register[i] & standard_enable_register[i]:
		status_byte_register[i] = status_byte_register[i] | 0b00100000
	if operation_event_register[i] & operation_enable_register[i]:
		status_byte_register[i] = status_byte_register[i] | 0b10000000
		
#Standard Event register
def set_standard_event_register(i):
	global standard_event_register, OPC_flag
	
	if OPC_flag[i] == 1:
		standard_event_register[i] = standard_event_register[i] | 0b00000001
		OPC_flag[i] = 0
	for e in xrange(0, 10):	#Will activate a bit for an old error if it is left in the queue.
							#Not as it should work, but it is okay.
		if -299 <= ERR[i][e] <= -200:
			standard_event_register[i] = standard_event_register[i] | 0b00010000
		if -199 <= ERR[i][e] <= -100:
			standard_event_register[i] = standard_event_register[i] | 0b00100000
	set_status_byte_register(i)

#Operation Event register
def set_operation_event_register(i):
	global operation_event_register
	
	if operation_shutdown_event_register[i] & operation_shutdown_enable_register[i]:
		operation_event_register[i] = operation_event_register[i] | 0b000001000000000
	if operation_cshare_event_register[i] & operation_cshare_enable_register[i]:
		operation_event_register[i] = operation_event_register[i] | 0b000100000000000

#Operation Shutdown Event register
def set_operation_shutdown_event_register(i):
	global operation_shutdown_event_register
	
	if operation_shutdown_protection_event_register[i] & operation_shutdown_protection_enable_register[i]:
		operation_shutdown_event_register[i] = operation_shutdown_event_register[i] | 0b0001

#Operation Shutdown Protection Event register
def set_operation_shutdown_protection_event_register(i):
	global operation_shutdown_protection_event_register
	
	if tripped_over_flag[i] == 1:
		operation_shutdown_protection_event_register[i] = operation_shutdown_protection_event_register[i] | 0b00000001
	if tripped_under_flag[i] == 1:
		operation_shutdown_protection_event_register[i] = operation_shutdown_protection_event_register[i] | 0b00000010
	set_operation_shutdown_event_register(i)
	set_operation_event_register(i)
	set_status_byte_register(i)
	
#Operation Cshare register
def set_operation_cshare_register(i):
	global operation_cshare_event_register
	
	#The way this register is defined is confusing. Cshare status should not need two bits.
	#Either it is controller or slave, so I assume the bit with slave gets turned off if
	#cshare is changed to controller.
	if current_share[i] == "CONT":
		operation_cshare_event_register[i] = operation_cshare_event_register[i] | 0b01
		operation_cshare_event_register[i] = operation_cshare_event_register[i] & 0b01
	if current_share[i] == "SLAV":
		operation_cshare_event_register[i] = operation_cshare_event_register[i] | 0b10
		operation_cshare_event_register[i] = operation_cshare_event_register[i] & 0b10
	set_operation_event_register(i)
	set_status_byte_register(i)
		
#Questionable Event register
def set_questionable_register(i):
	global questionable_event_register
	
	if questionable_voltage_event_register[i] & questionable_voltage_enable_register[i]:
		questionable_event_register[i] = questionable_event_register[i] | 0b00000001
	set_status_byte_register(i)

#Questionable Voltage Event register
def set_questionable_voltage_register(i):
	global questionable_voltage_event_register
	
	if tripped_over_flag != 0:
		questionable_voltage_event_register[i] = questionable_voltage_event_register[i] | 0b01
	if tripped_under_flag != 0:
		questionable_voltage_event_register[i] = questionable_voltage_event_register[i] | 0b10
	set_questionable_register(i)
		
#Questionable Temperature Event register
def set_questionable_temperature_register(i):
	global questionable_temperature_event_register
	
	#Have not implemented over temperature protection
	return None
