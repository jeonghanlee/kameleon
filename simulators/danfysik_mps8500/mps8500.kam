# -*- mode: python -*-
#
# author      : Jeong Han Lee
# email       : han.lee@esss.se
# copyright   : (C) 2016 European Spallation Source (ESS)
# version     : 0.0.3
#
# date        : Tuesday, November 29 18:40:37 CET 2016
#
# description : Kameleon simulator file for Danfysik System 8500

# import datetime
import ctypes

# _QUIET = True
# need to
# The real HW uses only CR, however, if we want to make this simulator
# works with telnet, we should use CR + LF, because the telnet sends <CR><LF>
# we use the CR + LF in the EPICS IOC st.cmd works with the simulator, and
# we will use CR in the EPICS IOC st.cmd works with a real HW.

#TERMINATOR_CMD = CR
TERMINATOR_CMD = CR + LF
TERMINATOR_STS = LF + CR


# Data (i.e. commands) received from the client are described in the "COMMANDS" list.
# The generic form of this list is: [description_1, command_1, status_1, wait_1]

COMMANDS = [["CLOCK read"     ,"CLOCK***"     ,1],
            ["CMD read"       ,"CMD***"       ,2],
            ["LOC"            ,"LOC"          ,3],
            ["REM"            ,"REM"          ,4],
            ["RLOCK"          ,"RLOCK"        ,5],
            ["BIT"            ,"BIT"          ,6],
            ["SETBIT"         ,"SETBIT***"       ,7]]



#[description_1, behavior_1, value_1, prefix_1, suffix_1, timeout_1]
STATUSES = [["CLOCK read"      ,CUSTOM  ,"clock_read()"                    ,"" ,""],
            ["CMD set"         ,CUSTOM  ,"get_status_line_in_cmd()"        ,"" ,""],
            ["LOC set"         ,CUSTOM  ,"set_status_line_in_cmd(\"LOC\")" ,"" ,""],
            ["REM set"         ,CUSTOM  ,"set_status_line_in_cmd(\"REM\")" ,"" ,""],
            ["RLOCK"           ,CUSTOM  ,"set_rem_lock_state()"            ,"" ,""],
            ["BIT"             ,CUSTOM  ,"print_bit()"                     ,"" ,""],
            ["SETBIT"          ,CUSTOM  ,"set_bit()"                       ,"" ,""]]

# retruns
# hour,min,sec,day,month,year'lf''cr'
# OR
# SYNTAX ERROR / ILLEGAL COMMAND 

internal_clock = ""
status_line_in_cmd = "REM"
rem_lock_state = False


# # . and 0 : False
# # ! and 1 : True
# #
# 01_main_power_off        = True
# 02_polarity_normal       = True
# 03_polarity_reversed     = False
# 04_reg_transformer       = True
# 05_dac16_status          = False
# 06_dac17_status          = False
# 07_unit                  = True
# # True : % / False : amps and volts
# 08_spare_interlock       = False
# 09_atransistor_fault     = False
# 10_sum_interlock         = False
# 11_dc_overcurrent        = False
# 12_dc_overload           = False
# 13_reg_module_fail       = False
# 14_pre_reg_fail          = False
# 15_phase_fail            = False
# 16_ps_waterflow_fail     = False
# 17_earth_leakage_fail    = False
# 18_therm_breaker_fuse    = False
# 19_ps_overtemp           = False
# 20_paincbtn_doorswitch   = False
# 21_magnet_waterflow_fail = False
# 22_magnet_overtemp       = False
# 23_ps_not_ready          = False
# 24_spare                 = False


c_uint = ctypes.c_uint

# With LittleEndianStructure
# 0x01 > main power off 1
# 0x02 > polarity_normal 1 
# 0x03 > main power off 1 and polarity_normal 1
# .
#
class Status_bits( ctypes.LittleEndianStructure ):
        _fields_ = [

                ("main_power_off",        c_uint, 1 ),   #0000 0000 0000 0000 0000 0001
                ("polarity_normal",       c_uint, 1 ),   #0000 0000 0000 0000 0000 0010
                ("polarity_reversed",     c_uint, 1 ),   #0000 0000 0000 0000 0000 0100  
                ("reg_transformer",       c_uint, 1 ),   #0000 0000 0000 0000 0000 1000  # 0x00000F

                ("dac16_status",          c_uint, 1 ),   #0000 0000 0000 0000 0001 0000
                ("dac17_status",          c_uint, 1 ),   #0000 0000 0000 0000 0010 0000
                ("unit",                  c_uint, 1 ),   #0000 0000 0000 0000 0100 0000
                ("spare_interlock",       c_uint, 1 ),   #0000 0000 0000 0000 1000 0000  # 0x0000F0

                ("atransistor_fault",     c_uint, 1 ),   #0000 0000 0000 0001 0000 0000
                ("sum_interlock",         c_uint, 1 ),   #0000 0000 0000 0010 0000 0000
                ("dc_overcurrent",        c_uint, 1 ),   #0000 0000 0000 0100 0000 0000
                ("dc_overload",           c_uint, 1 ),   #0000 0000 0000 1000 0000 0000  # 0x000F00

                ("reg_module_fail",       c_uint, 1 ),   #0000 0000 0001 0000 0000 0000
                ("pre_reg_fail",          c_uint, 1 ),   #0000 0000 0010 0000 0000 0000
                ("phase_fail",            c_uint, 1 ),   #0000 0000 0100 0000 0000 0000 
                ("ps_waterflow_fail",     c_uint, 1 ),   #0000 0000 1000 0000 0000 0000 # 0x00F000

                ("earth_leakage_fail",    c_uint, 1 ),   #0000 0001 0000 0000 0000 0000
                ("therm_breaker_fuse",    c_uint, 1 ),   #0000 0010 0000 0000 0000 0000
                ("ps_overtemp",           c_uint, 1 ),   #0000 0100 0000 0000 0000 0000
                ("paincbtn_doorswitch",   c_uint, 1 ),   #0000 1000 0000 0000 0000 0000 # 0x0F0000
                
                ("magnet_waterflow_fail", c_uint, 1 ),   #0001 0000 0000 0000 0000 0000
                ("magnet_overtemp",       c_uint, 1 ),   #0010 0000 0000 0000 0000 0000
                ("ps_not_ready",          c_uint, 1 ),   #0100 0000 0000 0000 0000 0000
                ("spare",                 c_uint, 1 ),   #1000 0000 0000 0000 0000 0000 # 0xF00000
                
                ("dummy00",               c_uint, 1 ),  
                ("dummy01",               c_uint, 1 ),  
                ("dummy02",               c_uint, 1 ),   
                ("dummy03",               c_uint, 1 ),   
                ("dummy04",               c_uint, 1 ),  
                ("dummy05",               c_uint, 1 ),  
                
                ("dummy06",               c_uint, 1 ), 
                ("dummy07",               c_uint, 1 ),
                ("dummy08",               c_uint, 1 ),
                ("dummy09",               c_uint, 1 ), 
                ("dummy10",               c_uint, 1 ),  
                ("dummy11",               c_uint, 1 )   
                
        ]
        
   
class Status( ctypes.Union ):
        _anonymous_ = ("bit",)
        _fields_ = [
                ("bit",     Status_bits ),
                ("as32Bit", c_uint    )
        ]
        
ps_status = Status()

# REMOTE : line-in-commnad : remote
# LOCAL  : line-in-command : local, the command is given from the remote line

def clock_read():
        _now = datetime.datetime.now()
        internal_clock = str(_now.hour);
        internal_clock += ",";
        internal_clock += str(_now.minute);
        internal_clock += ",";
        internal_clock += str(_now.second);
        internal_clock += ","
        internal_clock += str(_now.day);
        internal_clock += ","
        internal_clock += str(_now.month);
        internal_clock += ","
        internal_clock += str(_now.year);
      
        return internal_clock


def get_status_line_in_cmd():
	return "%s" %(status_line_in_cmd)

def set_status_line_in_cmd( arg ):
        global status_line_in_cmd
        global rem_lock_state
        
        status_line_in_cmd = arg

        # REM or LOC commands off RLOCK
        if status_line_in_cmd == "LOC" or status_line_in_cmd == "REM" :
                rem_lock_state = False
        # If auto-answer mode is set (FRom SW version SCS110)
        return "OK"

def set_rem_lock_state ():
        global rem_lock_state
        return_cmd = ""
        if rem_lock_state == True:
                return_cmd = "COMMAND ALREADY ACTIVE"
        else :
                if status_line_in_cmd == "REM":
                        rem_lock_state = True
                        # If auto-answer mode is set (FRom SW version SCS110)
                        return_cmd = "OK"
                else: # for this simulator, this state is LOC
                        return_cmd = "ILLEGAL COMMAND"

        return "%s" %(return_cmd)


def print_bit():
        
        global ps_status
 
        print " 1 %s" %(ps_status.main_power_off)
        print " 2 %s" %(ps_status.polarity_normal)       
        print " 3 %s" %(ps_status.polarity_reversed)
        print " 4 %s" %(ps_status.reg_transformer)       
        print " 5 %s" %(ps_status.dac16_status)          
        print " 6 %s" %(ps_status.dac17_status)          
        print " 7 %s" %(ps_status.unit)                  
        print " 8 %s" %(ps_status.spare_interlock)
        print " 9 %s" %(ps_status.atransistor_fault)
        print "10 %s" %(ps_status.sum_interlock)
        print "11 %s" %(ps_status.dc_overcurrent)
        print "12 %s" %(ps_status.dc_overload)
        print "13 %s" %(ps_status.reg_module_fail)
        print "14 %s" %(ps_status.pre_reg_fail)
        print "15 %s" %(ps_status.phase_fail)
        
        print "16 %s" %(ps_status.ps_waterflow_fail)
        print "17 %s" %(ps_status.earth_leakage_fail)
        print "18 %s" %(ps_status.therm_breaker_fuse)
        print "19 %s" %(ps_status.ps_overtemp)
        print "20 %s" %(ps_status.paincbtn_doorswitch)
        print "21 %s" %(ps_status.magnet_waterflow_fail)
        print "22 %s" %(ps_status.magnet_overtemp)
        print "23 %s" %(ps_status.ps_not_ready)
        print "24 %s" %(ps_status.spare)
                
        print "-----"
        print ps_status.as32Bit
        
def set_bit():
        # COMMAND_RECEIVED has "all string command with all args"
        args = COMMAND_RECEIVED.split()
        
        ps_status.as32Bit = int(args[1], 16)

        return "%s" %hex(ps_status.as32Bit)
   
        
